import 'aframe-forcegraph-component';
import Kapsule from 'kapsule';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var _3dForceGraphAr = Kapsule({
  props: {
    width: {},
    height: {},
    yOffset: {
      "default": 1.5
    },
    // marker size units
    glScale: {
      "default": 200
    },
    // gl units per marker width
    jsonUrl: {},
    graphData: {
      "default": {
        nodes: [],
        links: []
      }
    },
    numDimensions: {
      "default": 3
    },
    dagMode: {},
    dagLevelDistance: {},
    dagNodeFilter: {
      "default": function _default() {
        return true;
      }
    },
    onDagError: {
      "default": undefined
    },
    nodeRelSize: {
      "default": 4
    },
    // volume per val unit
    nodeId: {
      "default": 'id'
    },
    nodeVal: {
      "default": 'val'
    },
    nodeResolution: {
      "default": 8
    },
    // how many slice segments in the sphere's circumference
    nodeVisibility: {
      "default": true
    },
    nodeColor: {
      "default": 'color'
    },
    nodeAutoColorBy: {},
    nodeOpacity: {
      "default": 0.75
    },
    nodeThreeObject: {},
    nodeThreeObjectExtend: {
      "default": false
    },
    linkSource: {
      "default": 'source'
    },
    linkTarget: {
      "default": 'target'
    },
    linkVisibility: {
      "default": true
    },
    linkColor: {
      "default": 'color'
    },
    linkAutoColorBy: {},
    linkOpacity: {
      "default": 0.2
    },
    linkWidth: {
      "default": 0
    },
    linkResolution: {
      "default": 6
    },
    // how many radial segments in each line cylinder's geometry
    linkCurvature: {
      "default": 0
    },
    linkCurveRotation: {
      "default": 0
    },
    linkMaterial: {},
    linkThreeObject: {},
    linkThreeObjectExtend: {
      "default": false
    },
    linkPositionUpdate: {},
    linkDirectionalArrowLength: {
      "default": 0
    },
    linkDirectionalArrowColor: {},
    linkDirectionalArrowRelPos: {
      "default": 0.5
    },
    // value between 0<>1 indicating the relative pos along the (exposed) line
    linkDirectionalArrowResolution: {
      "default": 8
    },
    // how many slice segments in the arrow's conic circumference
    linkDirectionalParticles: {
      "default": 0
    },
    // animate photons travelling in the link direction
    linkDirectionalParticleSpeed: {
      "default": 0.01
    },
    // in link length ratio per frame
    linkDirectionalParticleWidth: {
      "default": 0.5
    },
    linkDirectionalParticleColor: {},
    linkDirectionalParticleResolution: {
      "default": 4
    },
    // how many slice segments in the particle sphere's circumference
    onNodeHover: {},
    onNodeClick: {},
    onLinkHover: {},
    onLinkClick: {},
    forceEngine: {
      "default": 'd3'
    },
    // d3 or ngraph
    d3AlphaMin: {
      "default": 0
    },
    d3AlphaDecay: {
      "default": 0.0228
    },
    d3VelocityDecay: {
      "default": 0.4
    },
    ngraphPhysics: {},
    warmupTicks: {
      "default": 0
    },
    // how many times to tick the force engine at init before starting to render
    cooldownTicks: {},
    cooldownTime: {
      "default": 15000
    },
    // ms
    onEngineTick: {},
    onEngineStop: {}
  },
  methods: _objectSpread2(_objectSpread2({}, Object.assign.apply(Object, [{}].concat(_toConsumableArray(['getGraphBbox', 'emitParticle', 'd3Force', 'd3ReheatSimulation', 'refresh'].map(function (method) {
    return _defineProperty({}, method, function (state) {
      var aframeComp = state.forcegraph.components.forcegraph;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var returnVal = aframeComp[method].apply(aframeComp, args);
      return returnVal === aframeComp ? this // chain based on this object, not the inner aframe component
      : returnVal;
    });
  }))))), {}, {
    _destructor: function _destructor() {
      this.graphData({
        nodes: [],
        links: []
      });
    }
  }),
  init: function init(domNode, state) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$markerAttrs = _ref2.markerAttrs,
        markerAttrs = _ref2$markerAttrs === void 0 ? {
      preset: 'hiro'
    } : _ref2$markerAttrs;

    // Wipe DOM
    domNode.innerHTML = '';
    state.container = document.createElement('div');
    domNode.appendChild(state.container); // Create scene

    var scene = document.createElement('a-scene');
    scene.setAttribute('embedded', '');
    scene.setAttribute('arjs', 'debugUIEnabled: false;');
    var arMarker = document.createElement('a-marker'); // add marker attributes

    Object.entries(markerAttrs).forEach(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          attr = _ref4[0],
          val = _ref4[1];

      return arMarker.setAttribute(attr, val);
    });
    scene.appendChild(arMarker); // Setup raycaster cursor

    var mouseCursor;
    scene.appendChild(mouseCursor = document.createElement('a-entity'));
    mouseCursor.setAttribute('cursor'
    /*, 'rayOrigin: mouse'*/
    ); // mouse raycaster has accuracy issues in ar.js: https://github.com/AR-js-org/AR.js/issues/40

    mouseCursor.setAttribute('raycaster', 'objects: [forcegraph]'); // Add forcegraph entity

    state.forcegraph = document.createElement('a-entity');
    state.forcegraph.setAttribute('forcegraph', null);
    arMarker.appendChild(state.forcegraph);
    var cameraEntity = document.createElement('a-entity');
    cameraEntity.setAttribute('camera', '');
    scene.appendChild(cameraEntity); // attach scene

    state.container.appendChild(scene); //domNode.appendChild(scene);
  },
  update: function update(state, changedProps) {
    changedProps.hasOwnProperty('width') && state.width && (state.container.style.width = "".concat(state.width, "px"));
    changedProps.hasOwnProperty('height') && state.height && (state.container.style.height = "".concat(state.height, "px"));
    changedProps.hasOwnProperty('glScale') && state.forcegraph.setAttribute('scale', _toConsumableArray(new Array(3)).map(function () {
      return 1 / state.glScale;
    }).join(' '));
    changedProps.hasOwnProperty('yOffset') && state.forcegraph.setAttribute('position', "0 ".concat(state.yOffset, " 0"));
    var passThroughProps = ['jsonUrl', 'numDimensions', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'nodeRelSize', 'nodeId', 'nodeVal', 'nodeResolution', 'nodeVisibility', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeThreeObject', 'nodeThreeObjectExtend', 'linkSource', 'linkTarget', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkThreeObjectExtend', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'onNodeHover', 'onNodeClick', 'onLinkHover', 'onLinkClick', 'forceEngine', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'ngraphPhysics', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'];
    var newProps = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(state).filter(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          prop = _ref6[0],
          val = _ref6[1];

      return changedProps.hasOwnProperty(prop) && passThroughProps.indexOf(prop) !== -1 && val !== undefined && val !== null;
    }).map(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
          key = _ref8[0],
          val = _ref8[1];

      return _defineProperty({}, key, val);
    })), _toConsumableArray(Object.entries(state.graphData).map(function (_ref10) {
      var _ref11 = _slicedToArray(_ref10, 2),
          key = _ref11[0],
          val = _ref11[1];

      return _defineProperty({}, key, val);
    }))));
    state.forcegraph.setAttribute('forcegraph', newProps);
  }
});

export { _3dForceGraphAr as default };
