function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import '../sigma/plugins.animate';
import '../sigma/layout.noverlap';
import ReactSigmaLayoutPlugin from './ReactSigmaLayoutPlugin';

/**

NOverlap component, starts noverlap sigma plugin once component is mounted.
It supposes that sigma graph is already in place, therefore component should not be
mounted while graph is unavailable. It can be used within Sigma component if graph is
preloaded, or within loader component, like LoadJSON.

@param {number} [nodeMargin=5]    additional minimum space to apply around each and every node
@param {number} [scaleNodes=1.2]  multiplier,  larger nodes will have more space around
@param {number} [gridSize=20]   number of rows and columns to use when dividing the nodes up into cell
@param {number} [permittedExpansion=1.1]  maximum ratio to apply to the bounding box
@param {number} speed     larger value increases the speed at the cost of precision
@param {number} maxIterations  iterations to run the algorithm for before stopping it
@param {number} easing     camera easing type for camera transition
@param {number} duration     duration of the transition for the easing method

It accepts all the parameters of sigma.layout.noverlap plugin described on its github page:
[see sigma plugin page for more details](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.noverlap)

@example
<Sigma graph={data}>
 <NOverlap gridSize={10} maxIterations={100}/>
</Sigma>

**/
var NOverlap = function NOverlap(props) {
  var s = props.sigma;
  if (s) return /*#__PURE__*/React.createElement(ReactSigmaLayoutPlugin, _extends({
    start: function start() {
      return s.startNoverlap();
    },
    config: function config(options) {
      return s.configNoverlap(options);
    },
    stop: function stop() {
      return !!s && !!s.stopNoverlap && s.stopNoverlap();
    }
  }, props));
  return null;
};

NOverlap.propTypes = {
  nodes: PropTypes.arrayOf(function () {
    return (typeof Sigma$Node === "function" ? PropTypes.instanceOf(Sigma$Node).isRequired : PropTypes.any.isRequired).apply(this, arguments);
  }),
  nodeMargin: PropTypes.number,
  scaleNodes: PropTypes.number,
  gridSize: PropTypes.number,
  permittedExpansion: PropTypes.number,
  speed: PropTypes.number,
  maxIterations: PropTypes.number,
  easing: function easing() {
    return (typeof Sigma$Easing === "function" ? PropTypes.instanceOf(Sigma$Easing) : PropTypes.any).apply(this, arguments);
  },
  duration: PropTypes.number,
  sigma: function (_sigma) {
    function sigma() {
      return _sigma.apply(this, arguments);
    }

    sigma.toString = function () {
      return _sigma.toString();
    };

    return sigma;
  }(function () {
    return (typeof sigma === "function" ? PropTypes.instanceOf(sigma) : PropTypes.any).apply(this, arguments);
  })
};
export default NOverlap;
import PropTypes from "prop-types";