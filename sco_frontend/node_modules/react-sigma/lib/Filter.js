"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

require("../sigma/plugins.filter");

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**

Filter component, interface for filter sigma plugin.
It supposes that sigma graph is already in place, therefore component should not be
mounted until graph is available. It can be used within Sigma component if graph is
preloaded, or within loader component, like NeoCypher.

Filter is hiding all nodes which do not apply to the provided nodesBy criteria.

@param {Nodes$Filter} nodesBy   will hide nodes where filter returns false

type Nodes$Filter = (node: Sigma$Node) => boolean;


**/
class Filter extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "render", () => null);
  }

  componentDidMount() {
    this.filter = new sigma.plugins.filter(this.props.sigma);

    this._apply(this.props);
  } // TODO: will it work in composition with ForceAtlas for instance?
  //It should hide nodes before rendering of subplugins, therefore used in componentWillUpdate.. is it right?


  componentWillUpdate(props) {
    if (props.nodesBy !== this.props.nodesBy || props.neighborsOf !== this.props.neighborsOf) this._apply(props);
  } // TODO: Composition is not working yet!!


  _apply(props) {
    this.filter.undo(["neighborsOf", "nodesBy"]);

    if (props.neighborsOf) {
      this.filter.neighborsOf(props.neighborsOf, "neighborsOf");
    }

    if (props.nodesBy) this.filter.nodesBy(props.nodesBy, "nodesBy");
    this.filter.apply();
    if (this.props.sigma) this.props.sigma.refresh();
  }

}

_defineProperty(Filter, "propTypes", {
  nodesBy: function () {
    return (typeof Nodes$Filter === "function" ? _propTypes.default.instanceOf(Nodes$Filter) : _propTypes.default.any).apply(this, arguments);
  },
  neighborsOf: _propTypes.default.string,
  sigma: function () {
    return (typeof Sigma === "function" ? _propTypes.default.instanceOf(Sigma) : _propTypes.default.any).apply(this, arguments);
  }
});

var _default = Filter;
exports.default = _default;