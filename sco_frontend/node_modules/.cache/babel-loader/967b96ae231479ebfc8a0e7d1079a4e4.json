{"ast":null,"code":"/* global AFRAME */\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nvar accessorFn = require('accessor-fn');\n\nif ('default' in accessorFn) {\n  // unwrap default export\n  accessorFn = accessorFn.default;\n}\n\nvar ThreeForceGraph = require('three-forcegraph');\n\nif ('default' in ThreeForceGraph) {\n  // unwrap default export\n  ThreeForceGraph = ThreeForceGraph.default;\n}\n\nvar parseJson = function parseJson(prop) {\n  return typeof prop === 'string' ? JSON.parse(prop) : prop; // already parsed\n};\n\nvar parseFn = function parseFn(prop) {\n  if (typeof prop === 'function') return prop; // already a function\n\n  var geval = eval; // Avoid using eval directly https://github.com/rollup/rollup/wiki/Troubleshooting#avoiding-eval\n\n  try {\n    var evalled = geval('(' + prop + ')');\n    return evalled;\n  } catch (e) {} // Can't eval, not a function\n\n\n  return null;\n};\n\nvar parseAccessor = function parseAccessor(prop) {\n  if (!isNaN(parseFloat(prop))) {\n    return parseFloat(prop);\n  } // parse numbers\n\n\n  if (parseFn(prop)) {\n    return parseFn(prop);\n  } // parse functions\n\n\n  return prop; // strings\n};\n/**\n * 3D Force-Directed Graph component for A-Frame.\n */\n\n\nAFRAME.registerComponent('forcegraph', {\n  schema: {\n    jsonUrl: {\n      type: 'string',\n      default: ''\n    },\n    nodes: {\n      parse: parseJson,\n      default: []\n    },\n    links: {\n      parse: parseJson,\n      default: []\n    },\n    numDimensions: {\n      type: 'number',\n      default: 3\n    },\n    dagMode: {\n      type: 'string',\n      default: ''\n    },\n    dagLevelDistance: {\n      type: 'number',\n      default: 0\n    },\n    dagNodeFilter: {\n      parse: parseFn,\n      default: function _default() {\n        return true;\n      }\n    },\n    onDagError: {\n      parse: parseFn,\n      default: undefined\n    },\n    nodeRelSize: {\n      type: 'number',\n      default: 4\n    },\n    // volume per val unit\n    nodeId: {\n      type: 'string',\n      default: 'id'\n    },\n    nodeVal: {\n      parse: parseAccessor,\n      default: 'val'\n    },\n    nodeResolution: {\n      type: 'number',\n      default: 8\n    },\n    // how many slice segments in the sphere's circumference\n    nodeVisibility: {\n      parse: parseAccessor,\n      default: true\n    },\n    nodeColor: {\n      parse: parseAccessor,\n      default: 'color'\n    },\n    nodeAutoColorBy: {\n      parse: parseAccessor,\n      default: ''\n    },\n    // color nodes with the same field equally\n    nodeOpacity: {\n      type: 'number',\n      default: 0.75\n    },\n    nodeThreeObject: {\n      parse: parseAccessor,\n      default: null\n    },\n    nodeThreeObjectExtend: {\n      parse: parseAccessor,\n      default: false\n    },\n    linkSource: {\n      type: 'string',\n      default: 'source'\n    },\n    linkTarget: {\n      type: 'string',\n      default: 'target'\n    },\n    linkVisibility: {\n      parse: parseAccessor,\n      default: true\n    },\n    linkColor: {\n      parse: parseAccessor,\n      default: 'color'\n    },\n    linkAutoColorBy: {\n      parse: parseAccessor,\n      default: ''\n    },\n    // color links with the same field equally\n    linkOpacity: {\n      type: 'number',\n      default: 0.2\n    },\n    linkWidth: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkResolution: {\n      type: 'number',\n      default: 6\n    },\n    // how many radial segments in each line cylinder's geometry\n    linkCurvature: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkCurveRotation: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkMaterial: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkThreeObject: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkThreeObjectExtend: {\n      parse: parseAccessor,\n      default: false\n    },\n    linkPositionUpdate: {\n      parse: parseFn,\n      default: null\n    },\n    linkDirectionalArrowLength: {\n      parse: parseAccessor,\n      default: 0\n    },\n    linkDirectionalArrowColor: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkDirectionalArrowRelPos: {\n      parse: parseAccessor,\n      default: 0.5\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: {\n      type: 'number',\n      default: 8\n    },\n    // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: {\n      parse: parseAccessor,\n      default: 0\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      parse: parseAccessor,\n      default: 0.01\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      parse: parseAccessor,\n      default: 0.5\n    },\n    linkDirectionalParticleColor: {\n      parse: parseAccessor,\n      default: null\n    },\n    linkDirectionalParticleResolution: {\n      type: 'number',\n      default: 4\n    },\n    // how many slice segments in the particle sphere's circumference\n    onNodeHover: {\n      parse: parseFn,\n      default: function _default() {}\n    },\n    onLinkHover: {\n      parse: parseFn,\n      default: function _default() {}\n    },\n    onNodeClick: {\n      parse: parseFn,\n      default: function _default() {}\n    },\n    onLinkClick: {\n      parse: parseFn,\n      default: function _default() {}\n    },\n    forceEngine: {\n      type: 'string',\n      default: 'd3'\n    },\n    // 'd3' or 'ngraph'\n    d3AlphaMin: {\n      type: 'number',\n      default: 0\n    },\n    d3AlphaDecay: {\n      type: 'number',\n      default: 0.0228\n    },\n    d3VelocityDecay: {\n      type: 'number',\n      default: 0.4\n    },\n    ngraphPhysics: {\n      parse: parseJson,\n      default: null\n    },\n    warmupTicks: {\n      type: 'int',\n      default: 0\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      type: 'int',\n      default: 1e18\n    },\n    // Simulate infinity (int parser doesn't accept Infinity object)\n    cooldownTime: {\n      type: 'int',\n      default: 15000\n    },\n    // ms\n    onEngineTick: {\n      parse: parseFn,\n      default: function _default() {}\n    },\n    onEngineStop: {\n      parse: parseFn,\n      default: function _default() {}\n    }\n  },\n  // Bind component methods\n  getGraphBbox: function getGraphBbox() {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    return this.forceGraph.getGraphBbox();\n  },\n  emitParticle: function emitParticle() {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    var forceGraph = this.forceGraph;\n    var returnVal = forceGraph.emitParticle.apply(forceGraph, arguments);\n    return returnVal === forceGraph ? this // return self, not the inner forcegraph component\n    : returnVal;\n  },\n  d3Force: function d3Force() {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    var forceGraph = this.forceGraph;\n    var returnVal = forceGraph.d3Force.apply(forceGraph, arguments);\n    return returnVal === forceGraph ? this // return self, not the inner forcegraph component\n    : returnVal;\n  },\n  d3ReheatSimulation: function d3ReheatSimulation() {\n    this.forceGraph && this.forceGraph.d3ReheatSimulation();\n    return this;\n  },\n  refresh: function refresh() {\n    this.forceGraph && this.forceGraph.refresh();\n    return this;\n  },\n  init: function init() {\n    var _this = this;\n\n    var state = this.state = {}; // Internal state\n    // Add info msg\n\n    state.infoEl = document.createElement('a-text');\n    state.infoEl.setAttribute('position', '0 -0.1 -1'); // Canvas center\n\n    state.infoEl.setAttribute('width', 1);\n    state.infoEl.setAttribute('align', 'center');\n    state.infoEl.setAttribute('color', 'lavender'); // Get camera dom element and attach fixed view elements to camera\n\n    var cameraEl = document.querySelector('a-entity[camera], a-camera');\n    cameraEl.appendChild(state.infoEl); // Keep reference to Three camera object\n\n    state.cameraObj = cameraEl.object3D.children.filter(function (child) {\n      return child.type === 'PerspectiveCamera';\n    })[0]; // On camera switch\n\n    this.el.sceneEl.addEventListener('camera-set-active', function (evt) {\n      // Switch camera reference\n      state.cameraObj = evt.detail.cameraEl.components.camera.camera;\n    }); // setup FG object\n\n    if (!this.forceGraph) this.forceGraph = new ThreeForceGraph(); // initialize forceGraph if it doesn't exist yet\n\n    this.forceGraph.onFinishUpdate(function () {\n      return _this.el.setObject3D('forcegraphGroup', _this.forceGraph);\n    }) // Bind forcegraph to elem\n    .onLoading(function () {\n      return state.infoEl.setAttribute('value', 'Loading...');\n    }) // Add loading msg\n    .onFinishLoading(function () {\n      return state.infoEl.setAttribute('value', '');\n    }); // prefer raycaster events over mouseenter/mouseleave because they expose immediately available intersection data via detail.getIntersection()\n\n    this.el.addEventListener('raycaster-intersected', function (ev) {\n      return state.hoverDetail = ev.detail;\n    });\n    this.el.addEventListener('raycaster-intersected-cleared', function (ev) {\n      return state.hoverDetail = ev.detail;\n    });\n    this.el.addEventListener('click', function () {\n      return state.hoverObj && _this.data['on' + (state.hoverObj.__graphObjType === 'node' ? 'Node' : 'Link') + 'Click'](state.hoverObj.__data);\n    });\n  },\n  remove: function remove() {\n    // Clean-up elems\n    this.state.infoEl.remove();\n    this.el.removeObject3D('forcegraphGroup');\n  },\n  update: function update(oldData) {\n    var comp = this;\n    var elData = this.data;\n    var diff = AFRAME.utils.diff(elData, oldData);\n    var fgProps = ['jsonUrl', 'numDimensions', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'nodeRelSize', 'nodeId', 'nodeVal', 'nodeResolution', 'nodeVisibility', 'nodeColor', 'nodeAutoColorBy', 'nodeOpacity', 'nodeThreeObject', 'nodeThreeObjectExtend', 'linkSource', 'linkTarget', 'linkVisibility', 'linkColor', 'linkAutoColorBy', 'linkOpacity', 'linkWidth', 'linkResolution', 'linkCurvature', 'linkCurveRotation', 'linkMaterial', 'linkThreeObject', 'linkThreeObjectExtend', 'linkPositionUpdate', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalArrowResolution', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleResolution', 'forceEngine', 'd3AlphaMin', 'd3AphaDecay', 'd3VelocityDecay', 'ngraphPhysics', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'];\n    fgProps.filter(function (p) {\n      return p in diff;\n    }).forEach(function (p) {\n      comp.forceGraph[p](elData[p] !== '' ? elData[p] : null);\n    }); // Convert blank values into nulls\n\n    if ('nodes' in diff || 'links' in diff) {\n      comp.forceGraph.graphData({\n        nodes: elData.nodes,\n        links: elData.links\n      });\n    }\n  },\n  tick: function tick(t, td) {\n    var state = this.state;\n    var props = this.data; // Update hover (intersected) object\n\n    var intersection = state.hoverDetail ? state.hoverDetail.getIntersection ? state.hoverDetail.getIntersection(this.el) // available in raycaster-intersected events\n    : state.hoverDetail.intersection || undefined // available in mouseenter/mouseleave events (with delayed update)\n    : undefined; // Note:\n    // Unfortunately we only have access to the intersected object closer to the camera (1st element in the raycaster intersectObjects result),\n    // there is no \".getIntersections()\" method available in the event details. Therefore, we can't prioritize hover on nodes over links, or even exclude\n    // objects that are neither nodes or links. This makes the interaction a bit erratic if nodes have a lot of links in front.\n    // Configuring the raycaster.params.Line.threshold might help with this somewhat, but that config is also not available via the a-frame raycaster component.\n    // recurse up until forcegraph obj is found\n\n    var topObject = intersection ? intersection.object : undefined;\n\n    while (topObject && !topObject.hasOwnProperty('__graphObjType')) {\n      topObject = topObject.parent;\n    }\n\n    if (topObject !== state.hoverObj) {\n      var prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;\n      var prevObjData = state.hoverObj ? state.hoverObj.__data : null;\n      var objType = topObject ? topObject.__graphObjType : null;\n      var objData = topObject ? topObject.__data : null;\n\n      if (prevObjType && prevObjType !== objType) {\n        // Hover out\n        props['on' + (prevObjType === 'node' ? 'Node' : 'Link') + 'Hover'](null, prevObjData);\n      }\n\n      if (objType) {\n        // Hover in\n        props['on' + (objType === 'node' ? 'Node' : 'Link') + 'Hover'](objData, prevObjType === objType ? prevObjData : null);\n      }\n\n      state.hoverObj = topObject;\n    } // Run force-graph ticker\n\n\n    this.forceGraph.tickFrame();\n  }\n});","map":null,"metadata":{},"sourceType":"script"}