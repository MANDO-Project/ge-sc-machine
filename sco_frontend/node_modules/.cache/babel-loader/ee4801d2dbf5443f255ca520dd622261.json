{"ast":null,"code":"var e = function e() {};\n\ne.computeCentroids = function (e) {\n  var t, n, r;\n\n  for (t = 0, n = e.faces.length; t < n; t++) {\n    (r = e.faces[t]).centroid = new THREE.Vector3(0, 0, 0), r.centroid.add(e.vertices[r.a]), r.centroid.add(e.vertices[r.b]), r.centroid.add(e.vertices[r.c]), r.centroid.divideScalar(3);\n  }\n}, e.roundNumber = function (e, t) {\n  return Number(e.toFixed(t));\n}, e.sample = function (e) {\n  return e[Math.floor(Math.random() * e.length)];\n}, e.mergeVertexIds = function (e, t) {\n  var n = [];\n  if (e.forEach(function (e) {\n    t.indexOf(e) >= 0 && n.push(e);\n  }), n.length < 2) return [];\n  n.includes(e[0]) && n.includes(e[e.length - 1]) && e.push(e.shift()), n.includes(t[0]) && n.includes(t[t.length - 1]) && t.push(t.shift()), n = [], e.forEach(function (e) {\n    t.includes(e) && n.push(e);\n  });\n\n  for (var r = n[1], o = n[0], i = e.slice(); i[0] !== r;) {\n    i.push(i.shift());\n  }\n\n  for (var s = 0, u = t.slice(); u[0] !== o;) {\n    if (u.push(u.shift()), s++ > 10) throw new Error(\"Unexpected state\");\n  }\n\n  return u.shift(), u.pop(), i = i.concat(u);\n}, e.setPolygonCentroid = function (e, t) {\n  var n = new THREE.Vector3(),\n      r = t.vertices;\n  e.vertexIds.forEach(function (e) {\n    n.add(r[e]);\n  }), n.divideScalar(e.vertexIds.length), e.centroid.copy(n);\n}, e.cleanPolygon = function (e, t) {\n  for (var n = [], r = t.vertices, o = 0; o < e.vertexIds.length; o++) {\n    var i,\n        s,\n        u,\n        c = r[e.vertexIds[o]];\n    0 === o ? (i = e.vertexIds[1], s = e.vertexIds[e.vertexIds.length - 1]) : o === e.vertexIds.length - 1 ? (i = e.vertexIds[0], s = e.vertexIds[e.vertexIds.length - 2]) : (i = e.vertexIds[o + 1], s = e.vertexIds[o - 1]), u = r[s];\n    var h = r[i].clone().sub(c),\n        a = u.clone().sub(c),\n        d = h.angleTo(a);\n\n    if (d > Math.PI - .01 && d < Math.PI + .01) {\n      var f = [];\n      e.neighbours.forEach(function (t) {\n        t.vertexIds.includes(e.vertexIds[o]) || f.push(t);\n      }), e.neighbours = f;\n    } else n.push(e.vertexIds[o]);\n  }\n\n  e.vertexIds = n, this.setPolygonCentroid(e, t);\n}, e.isConvex = function (e, t) {\n  var n = t.vertices;\n  if (e.vertexIds.length < 3) return !1;\n\n  for (var r = !0, o = [], i = 0; i < e.vertexIds.length; i++) {\n    var s,\n        u,\n        c = n[e.vertexIds[i]];\n    0 === i ? (s = n[e.vertexIds[1]], u = n[e.vertexIds[e.vertexIds.length - 1]]) : i === e.vertexIds.length - 1 ? (s = n[e.vertexIds[0]], u = n[e.vertexIds[e.vertexIds.length - 2]]) : (s = n[e.vertexIds[i + 1]], u = n[e.vertexIds[i - 1]]);\n    var h = s.clone().sub(c),\n        a = u.clone().sub(c),\n        d = h.angleTo(a);\n    if (d === Math.PI || 0 === d) return !1;\n    var f = h.cross(a).y;\n    o.push(f);\n  }\n\n  return o.forEach(function (e) {\n    0 === e && (r = !1);\n  }), o.forEach(o[0] > 0 ? function (e) {\n    e < 0 && (r = !1);\n  } : function (e) {\n    e > 0 && (r = !1);\n  }), r;\n}, e.distanceToSquared = function (e, t) {\n  var n = e.x - t.x,\n      r = e.y - t.y,\n      o = e.z - t.z;\n  return n * n + r * r + o * o;\n}, e.isPointInPoly = function (e, t) {\n  for (var n = !1, r = -1, o = e.length, i = o - 1; ++r < o; i = r) {\n    (e[r].z <= t.z && t.z < e[i].z || e[i].z <= t.z && t.z < e[r].z) && t.x < (e[i].x - e[r].x) * (t.z - e[r].z) / (e[i].z - e[r].z) + e[r].x && (n = !n);\n  }\n\n  return n;\n}, e.isVectorInPolygon = function (e, t, n) {\n  var r = 1e5,\n      o = -1e5,\n      i = [];\n  return t.vertexIds.forEach(function (e) {\n    r = Math.min(n[e].y, r), o = Math.max(n[e].y, o), i.push(n[e]);\n  }), !!(e.y < o + .5 && e.y > r - .5 && this.isPointInPoly(i, e));\n}, e.triarea2 = function (e, t, n) {\n  return (n.x - e.x) * (t.z - e.z) - (t.x - e.x) * (n.z - e.z);\n}, e.vequal = function (e, t) {\n  return this.distanceToSquared(e, t) < 1e-5;\n};\n\nvar t = function t(e) {\n  this.content = [], this.scoreFunction = e;\n};\n\nt.prototype.push = function (e) {\n  this.content.push(e), this.sinkDown(this.content.length - 1);\n}, t.prototype.pop = function () {\n  var e = this.content[0],\n      t = this.content.pop();\n  return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), e;\n}, t.prototype.remove = function (e) {\n  var t = this.content.indexOf(e),\n      n = this.content.pop();\n  t !== this.content.length - 1 && (this.content[t] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.sinkDown(t) : this.bubbleUp(t));\n}, t.prototype.size = function () {\n  return this.content.length;\n}, t.prototype.rescoreElement = function (e) {\n  this.sinkDown(this.content.indexOf(e));\n}, t.prototype.sinkDown = function (e) {\n  for (var t = this.content[e]; e > 0;) {\n    var n = (e + 1 >> 1) - 1,\n        r = this.content[n];\n    if (!(this.scoreFunction(t) < this.scoreFunction(r))) break;\n    this.content[n] = t, this.content[e] = r, e = n;\n  }\n}, t.prototype.bubbleUp = function (e) {\n  for (var t = this.content.length, n = this.content[e], r = this.scoreFunction(n);;) {\n    var o = e + 1 << 1,\n        i = o - 1,\n        s = null,\n        u = void 0;\n    if (i < t) (u = this.scoreFunction(this.content[i])) < r && (s = i);\n    if (o < t) this.scoreFunction(this.content[o]) < (null === s ? r : u) && (s = o);\n    if (null === s) break;\n    this.content[e] = this.content[s], this.content[s] = n, e = s;\n  }\n};\n\nvar n = function n() {};\n\nn.init = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    n.f = 0, n.g = 0, n.h = 0, n.cost = 1, n.visited = !1, n.closed = !1, n.parent = null;\n  }\n}, n.cleanUp = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    delete n.f, delete n.g, delete n.h, delete n.cost, delete n.visited, delete n.closed, delete n.parent;\n  }\n}, n.heap = function () {\n  return new t(function (e) {\n    return e.f;\n  });\n}, n.search = function (e, t, n) {\n  this.init(e);\n  var r = this.heap();\n\n  for (r.push(t); r.size() > 0;) {\n    var o = r.pop();\n\n    if (o === n) {\n      for (var i = o, s = []; i.parent;) {\n        s.push(i), i = i.parent;\n      }\n\n      return this.cleanUp(s), s.reverse();\n    }\n\n    o.closed = !0;\n\n    for (var u = this.neighbours(e, o), c = 0, h = u.length; c < h; c++) {\n      var a = u[c];\n\n      if (!a.closed) {\n        var d = o.g + a.cost,\n            f = a.visited;\n\n        if (!f || d < a.g) {\n          if (a.visited = !0, a.parent = o, !a.centroid || !n.centroid) throw new Error(\"Unexpected state\");\n          a.h = a.h || this.heuristic(a.centroid, n.centroid), a.g = d, a.f = a.g + a.h, f ? r.rescoreElement(a) : r.push(a);\n        }\n      }\n    }\n  }\n\n  return [];\n}, n.heuristic = function (t, n) {\n  return e.distanceToSquared(t, n);\n}, n.neighbours = function (e, t) {\n  for (var n = [], r = 0; r < t.neighbours.length; r++) {\n    n.push(e[t.neighbours[r]]);\n  }\n\n  return n;\n};\n\nvar r = 1,\n    o = function o() {};\n\no.buildZone = function (t) {\n  var n = this,\n      r = this._buildNavigationMesh(t),\n      o = {};\n\n  r.vertices.forEach(function (t) {\n    t.x = e.roundNumber(t.x, 2), t.y = e.roundNumber(t.y, 2), t.z = e.roundNumber(t.z, 2);\n  }), o.vertices = r.vertices;\n\n  var i = this._buildPolygonGroups(r);\n\n  o.groups = [];\n\n  var s = function s(e, t) {\n    for (var n = 0; n < e.length; n++) {\n      if (t === e[n]) return n;\n    }\n  };\n\n  return i.forEach(function (t) {\n    var r = [];\n    t.forEach(function (o) {\n      var i = o.neighbours.map(function (e) {\n        return s(t, e);\n      }),\n          u = o.neighbours.map(function (e) {\n        return n._getSharedVerticesInOrder(o, e);\n      });\n      o.centroid.x = e.roundNumber(o.centroid.x, 2), o.centroid.y = e.roundNumber(o.centroid.y, 2), o.centroid.z = e.roundNumber(o.centroid.z, 2), r.push({\n        id: s(t, o),\n        neighbours: i,\n        vertexIds: o.vertexIds,\n        centroid: o.centroid,\n        portals: u\n      });\n    }), o.groups.push(r);\n  }), o;\n}, o._buildNavigationMesh = function (t) {\n  return e.computeCentroids(t), t.mergeVertices(), this._buildPolygonsFromGeometry(t);\n}, o._buildPolygonGroups = function (e) {\n  var t = [],\n      n = 0,\n      r = function r(e) {\n    e.neighbours.forEach(function (t) {\n      void 0 === t.group && (t.group = e.group, r(t));\n    });\n  };\n\n  return e.polygons.forEach(function (e) {\n    void 0 === e.group && (e.group = n++, r(e)), t[e.group] || (t[e.group] = []), t[e.group].push(e);\n  }), t;\n}, o._buildPolygonNeighbours = function (e, t, n) {\n  var r = new Set(),\n      o = n.get(e.vertexIds[0]),\n      i = n.get(e.vertexIds[1]),\n      s = n.get(e.vertexIds[2]);\n  o.forEach(function (e) {\n    (i.has(e) || s.has(e)) && r.add(t.polygons[e]);\n  }), i.forEach(function (e) {\n    s.has(e) && r.add(t.polygons[e]);\n  }), e.neighbours = Array.from(r);\n}, o._buildPolygonsFromGeometry = function (e) {\n  for (var t = this, n = [], o = e.vertices, i = e.faceVertexUvs, s = new Map(), u = 0; u < o.length; u++) {\n    s.set(u, new Set());\n  }\n\n  e.faces.forEach(function (e) {\n    n.push({\n      id: r++,\n      vertexIds: [e.a, e.b, e.c],\n      centroid: e.centroid,\n      normal: e.normal,\n      neighbours: []\n    }), s.get(e.a).add(n.length - 1), s.get(e.b).add(n.length - 1), s.get(e.c).add(n.length - 1);\n  });\n  var c = {\n    polygons: n,\n    vertices: o,\n    faceVertexUvs: i\n  };\n  return n.forEach(function (e) {\n    t._buildPolygonNeighbours(e, c, s);\n  }), c;\n}, o._getSharedVerticesInOrder = function (e, t) {\n  var n = e.vertexIds,\n      r = t.vertexIds,\n      o = new Set();\n  if (n.forEach(function (e) {\n    r.includes(e) && o.add(e);\n  }), o.size < 2) return [];\n  o.has(n[0]) && o.has(n[n.length - 1]) && n.push(n.shift()), o.has(r[0]) && o.has(r[r.length - 1]) && r.push(r.shift());\n  var i = [];\n  return n.forEach(function (e) {\n    r.includes(e) && i.push(e);\n  }), i;\n};\n\nvar i = function i() {\n  this.portals = [];\n};\n\ni.prototype.push = function (e, t) {\n  void 0 === t && (t = e), this.portals.push({\n    left: e,\n    right: t\n  });\n}, i.prototype.stringPull = function () {\n  var t,\n      n,\n      r,\n      o = this.portals,\n      i = [],\n      s = 0,\n      u = 0,\n      c = 0;\n  n = o[0].left, r = o[0].right, i.push(t = o[0].left);\n\n  for (var h = 1; h < o.length; h++) {\n    var a = o[h].left,\n        d = o[h].right;\n\n    if (e.triarea2(t, r, d) <= 0) {\n      if (!(e.vequal(t, r) || e.triarea2(t, n, d) > 0)) {\n        i.push(n), n = t = n, r = t, u = s = u, c = s, h = s;\n        continue;\n      }\n\n      r = d, c = h;\n    }\n\n    if (e.triarea2(t, n, a) >= 0) {\n      if (!(e.vequal(t, n) || e.triarea2(t, r, a) < 0)) {\n        i.push(r), n = t = r, r = t, u = s = c, c = s, h = s;\n        continue;\n      }\n\n      n = a, u = h;\n    }\n  }\n\n  return 0 !== i.length && e.vequal(i[i.length - 1], o[o.length - 1].left) || i.push(o[o.length - 1].left), this.path = i, i;\n};\n\nvar s,\n    u,\n    c,\n    h,\n    a,\n    d,\n    f = function f() {\n  this.zones = {};\n};\n\nf.createZone = function (e) {\n  return o.buildZone(e);\n}, f.prototype.setZoneData = function (e, t) {\n  this.zones[e] = t;\n}, f.prototype.getGroup = function (t, n) {\n  if (!this.zones[t]) return null;\n  var r = null,\n      o = Math.pow(50, 2);\n  return this.zones[t].groups.forEach(function (t, i) {\n    t.forEach(function (t) {\n      var s = e.distanceToSquared(t.centroid, n);\n      s < o && (r = i, o = s);\n    });\n  }), r;\n}, f.prototype.getRandomNode = function (t, n, r, o) {\n  if (!this.zones[t]) return new THREE.Vector3();\n  r = r || null, o = o || 0;\n  var i = [];\n  return this.zones[t].groups[n].forEach(function (t) {\n    r && o ? e.distanceToSquared(r, t.centroid) < o * o && i.push(t.centroid) : i.push(t.centroid);\n  }), e.sample(i) || new THREE.Vector3();\n}, f.prototype.getClosestNode = function (t, n, r, o) {\n  void 0 === o && (o = !1);\n  var i = this.zones[n].vertices,\n      s = null,\n      u = Infinity;\n  return this.zones[n].groups[r].forEach(function (n) {\n    var r = e.distanceToSquared(n.centroid, t);\n    r < u && (!o || e.isVectorInPolygon(t, n, i)) && (s = n, u = r);\n  }), s;\n}, f.prototype.findPath = function (e, t, r, o) {\n  var s = this.zones[r].groups[o],\n      u = this.zones[r].vertices,\n      c = this.getClosestNode(e, r, o),\n      h = this.getClosestNode(t, r, o, !0);\n  if (!c || !h) return null;\n\n  var a = n.search(s, c, h),\n      d = function d(e, t) {\n    for (var n = 0; n < e.neighbours.length; n++) {\n      if (e.neighbours[n] === t.id) return e.portals[n];\n    }\n  },\n      f = new i();\n\n  f.push(e);\n\n  for (var l = 0; l < a.length; l++) {\n    var v = a[l + 1];\n\n    if (v) {\n      var p = d(a[l], v);\n      f.push(u[p[0]], u[p[1]]);\n    }\n  }\n\n  f.push(t), f.stringPull();\n  var g = f.path.map(function (e) {\n    return new THREE.Vector3(e.x, e.y, e.z);\n  });\n  return g.shift(), g;\n}, f.prototype.clampStep = (c = new THREE.Vector3(), h = new THREE.Plane(), a = new THREE.Triangle(), d = new THREE.Vector3(), function (e, t, n, r, o, i) {\n  var f = this.zones[r].vertices,\n      l = this.zones[r].groups[o],\n      v = [n],\n      p = {};\n  p[n.id] = 0, s = void 0, d.set(0, 0, 0), u = Infinity, h.setFromCoplanarPoints(f[n.vertexIds[0]], f[n.vertexIds[1]], f[n.vertexIds[2]]), h.projectPoint(t, c), t.copy(c);\n\n  for (var g = v.pop(); g; g = v.pop()) {\n    a.set(f[g.vertexIds[0]], f[g.vertexIds[1]], f[g.vertexIds[2]]), a.closestPointToPoint(t, c), c.distanceToSquared(t) < u && (s = g, d.copy(c), u = c.distanceToSquared(t));\n    var x = p[g];\n    if (!(x > 2)) for (var I = 0; I < g.neighbours.length; I++) {\n      var b = l[g.neighbours[I]];\n      b.id in p || (v.push(b), p[b.id] = x + 1);\n    }\n  }\n\n  return i.copy(d), s;\n});\nexport { f as Pathfinding };","map":null,"metadata":{},"sourceType":"module"}