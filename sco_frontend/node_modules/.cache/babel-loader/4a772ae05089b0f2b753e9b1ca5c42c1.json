{"ast":null,"code":"/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\nmodule.exports = THREE.ColladaLoader = function (manager) {\n  this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.ColladaLoader.prototype = {\n  constructor: THREE.ColladaLoader,\n  crossOrigin: 'anonymous',\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new THREE.FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.load(url, function (text) {\n      onLoad(scope.parse(text, path));\n    }, onProgress, onError);\n  },\n  setPath: function setPath(value) {\n    this.path = value;\n    return this;\n  },\n  setResourcePath: function setResourcePath(value) {\n    this.resourcePath = value;\n    return this;\n  },\n  options: {\n    set convertUpAxis(value) {\n      console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n    }\n\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  },\n  parse: function parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      var array = [];\n      var childNodes = xml.childNodes;\n\n      for (var i = 0, l = childNodes.length; i < l; i++) {\n        var child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      var parts = text.trim().split(/\\s+/);\n      var array = new Array(parts.length);\n\n      for (var i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      var library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        var elements = getElementsByTagName(library, nodeName);\n\n        for (var i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (var name in data) {\n        var object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      var data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.animations[xml.getAttribute('id')] = data;\n    }\n\n    function parseAnimationSampler(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      var data = {};\n      var target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      var parts = target.split('/');\n      var id = parts.shift();\n      var sid = parts.shift(); // check selection syntax\n\n      var arraySyntax = sid.indexOf('(') !== -1;\n      var memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        var indices = sid.split('(');\n        sid = indices.shift();\n\n        for (var i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      var tracks = [];\n      var channels = data.channels;\n      var samplers = data.samplers;\n      var sources = data.sources;\n\n      for (var target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          var channel = channels[target];\n          var sampler = samplers[channel.sampler];\n          var inputId = sampler.inputs.INPUT;\n          var outputId = sampler.inputs.OUTPUT;\n          var inputSource = sources[inputId];\n          var outputSource = sources[outputId];\n          var animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      var node = library.nodes[channel.id];\n      var object3D = getNode(node.id);\n      var transform = node.transforms[channel.sid];\n      var defaultMatrix = node.matrix.clone().transpose();\n      var time, stride;\n      var i, il, j, jl;\n      var data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              var value = outputSource.array[stride];\n              var index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      var keyframes = prepareAnimationData(data, defaultMatrix);\n      var animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      var keyframes = []; // transfer data into a sortable array\n\n      for (var time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (var i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    var position = new THREE.Vector3();\n    var scale = new THREE.Vector3();\n    var quaternion = new THREE.Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      var keyframes = animation.keyframes;\n      var name = animation.name;\n      var times = [];\n      var positionData = [];\n      var quaternionData = [];\n      var scaleData = [];\n\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n        var time = keyframe.time;\n        var value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      var keyframe;\n      var empty = true;\n      var i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      var prev, next;\n\n      for (var i = 0, l = keyframes.length; i < l; i++) {\n        var keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        var keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      var data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      var tracks = [];\n      var name = data.name;\n      var duration = data.end - data.start || -1;\n      var animations = data.animations;\n\n      for (var i = 0, il = animations.length; i < il; i++) {\n        var animationTracks = getAnimation(animations[i]);\n\n        for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new THREE.AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      var data = {\n        sources: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            var id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      var data = {\n        inputs: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var semantic = child.getAttribute('semantic');\n            var id = parseId(child.getAttribute('source'));\n            var offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      var build = {\n        id: data.id\n      };\n      var geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      var BONE_LIMIT = 4;\n      var build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      var sources = data.sources;\n      var vertexWeights = data.vertexWeights;\n      var vcount = vertexWeights.vcount;\n      var v = vertexWeights.v;\n      var jointOffset = vertexWeights.inputs.JOINT.offset;\n      var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      var jointSource = data.sources[data.joints.inputs.JOINT];\n      var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      var stride = 0;\n      var i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        var vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          var skinIndex = v[stride + jointOffset];\n          var weightId = v[stride + weightOffset];\n          var skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          var d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new THREE.Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        var name = jointSource.array[i];\n        var boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      var data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      var data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      var data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      var sid = xml.getAttribute('sid');\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.getAttribute('opaque'),\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      var data = {\n        technique: {}\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      var loader;\n      var extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      var effect = getEffect(data.url);\n      var technique = effect.profile.technique;\n      var extra = effect.profile.extra;\n      var material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new THREE.MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new THREE.MeshLambertMaterial();\n          break;\n\n        default:\n          material = new THREE.MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name;\n\n      function getTexture(textureObject) {\n        var sampler = effect.profile.samplers[textureObject.id];\n        var image = null; // get image\n\n        if (sampler !== undefined) {\n          var surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          var loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            var texture = loader.load(image);\n            var extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              var technique = extra.technique;\n              texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = THREE.RepeatWrapping;\n              texture.wrapT = THREE.RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n          return null;\n        }\n      }\n\n      var parameters = technique.parameters;\n\n      for (var key in parameters) {\n        var parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      var transparent = parameters['transparent'];\n      var transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          var color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n        material.side = THREE.DoubleSide;\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      var data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      var camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          var ymag = data.optics.parameters.ymag;\n          var xmag = data.optics.parameters.xmag;\n          var aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new THREE.PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name;\n      return camera;\n    }\n\n    function getCamera(id) {\n      var data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            var array = parseFloats(child.textContent);\n            data.color = new THREE.Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            var f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      var light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new THREE.DirectionalLight();\n          break;\n\n        case 'point':\n          light = new THREE.PointLight();\n          break;\n\n        case 'spot':\n          light = new THREE.SpotLight();\n          break;\n\n        case 'ambient':\n          light = new THREE.AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      var data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      var mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (var i = 0; i < mesh.childNodes.length; i++) {\n        var child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        var id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      var data = {\n        array: [],\n        stride: 3\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            var accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      var data = {};\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      var primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            var id = parseId(child.getAttribute('source'));\n            var semantic = child.getAttribute('semantic');\n            var offset = parseInt(child.getAttribute('offset'));\n            var set = parseInt(child.getAttribute('set'));\n            var inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      var build = {};\n\n      for (var i = 0; i < primitives.length; i++) {\n        var primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      var count = 0;\n\n      for (var i = 0, l = primitives.length; i < l; i++) {\n        var primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      var build = {};\n      var sources = data.sources;\n      var vertices = data.vertices;\n      var primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      var groupedPrimitives = groupPrimitives(primitives);\n\n      for (var type in groupedPrimitives) {\n        var primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      var build = {};\n      var position = {\n        array: [],\n        stride: 0\n      };\n      var normal = {\n        array: [],\n        stride: 0\n      };\n      var uv = {\n        array: [],\n        stride: 0\n      };\n      var uv2 = {\n        array: [],\n        stride: 0\n      };\n      var color = {\n        array: [],\n        stride: 0\n      };\n      var skinIndex = {\n        array: [],\n        stride: 4\n      };\n      var skinWeight = {\n        array: [],\n        stride: 4\n      };\n      var geometry = new THREE.BufferGeometry();\n      var materialKeys = [];\n      var start = 0;\n\n      for (var p = 0; p < primitives.length; p++) {\n        var primitive = primitives[p];\n        var inputs = primitive.inputs; // groups\n\n        var count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (var g = 0; g < primitive.count; g++) {\n              var vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (var name in inputs) {\n          var input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (var key in vertices) {\n                var id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    var prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      var count = (position.array.length - prevLength) / position.stride;\n\n                      for (var i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.addAttribute('uv2', new THREE.Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.addAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      var indices = primitive.p;\n      var stride = primitive.stride;\n      var vcount = primitive.vcount;\n\n      function pushVector(i) {\n        var index = indices[i + offset] * sourceStride;\n        var length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      var sourceArray = source.array;\n      var sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        var index = 0;\n\n        for (var i = 0, l = vcount.length; i < l; i++) {\n          var count = vcount[i];\n\n          if (count === 4) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            var d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            var a = index + stride * 0;\n            var b = index + stride * 1;\n            var c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (var k = 1, kl = count - 2; k <= kl; k++) {\n              var a = index + stride * 0;\n              var b = index + stride * k;\n              var c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (var i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      var data;\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml, data) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new THREE.Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            var max = child.getElementsByTagName('max')[0];\n            var min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      var data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      var data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      var data = {\n        type: xml.nodeName\n      };\n      var array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new THREE.Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new THREE.Vector3();\n          data.obj.fromArray(array);\n          data.angle = THREE.Math.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      var data = {\n        bindJointAxis: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      var data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            var param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      var visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      var kinematicsModel = getKinematicsModel(kinematicsModelId);\n      var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      var visualScene = getVisualScene(visualSceneId);\n      var bindJointAxis = kinematicsScene.bindJointAxis;\n      var jointMap = {};\n\n      for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n        var axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transfrom element\n          var parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        var visualElementName = visualElement.getAttribute('name');\n        var joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      var m0 = new THREE.Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function getJointValue(jointIndex) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n          }\n        },\n        setJointValue: function setJointValue(jointIndex, value) {\n          var jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            var joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              var object = jointData.object;\n              var axis = joint.axis;\n              var transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (var i = 0; i < transforms.length; i++) {\n                var transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, THREE.Math.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      var transforms = [];\n      var xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            var matrix = new THREE.Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            var vector = new THREE.Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var vector = new THREE.Vector3().fromArray(array);\n            var angle = THREE.Math.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      var elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    var matrix = new THREE.Matrix4();\n    var vector = new THREE.Vector3();\n\n    function parseNode(xml) {\n      var data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new THREE.Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            var array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            var array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            var array = parseFloats(child.textContent);\n            var angle = THREE.Math.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            var array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      var data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            var instances = child.getElementsByTagName('instance_material');\n\n            for (var j = 0; j < instances.length; j++) {\n              var instance = instances[j];\n              var symbol = instance.getAttribute('symbol');\n              var target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      var boneData = [];\n      var sortedBoneData = [];\n      var i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        var skeleton = skeletons[i];\n        var root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          var visualScene = library.visualScenes[skeleton];\n          var children = visualScene.children;\n\n          for (var j = 0; j < children.length; j++) {\n            var child = children[j];\n\n            if (child.type === 'JOINT') {\n              var root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      var bones = [];\n      var boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new THREE.Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          var boneInverse; // retrieve the boneInverse from the controller data\n\n          for (var i = 0; i < joints.length; i++) {\n            var joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new THREE.Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      var objects = [];\n      var matrix = data.matrix;\n      var nodes = data.nodes;\n      var type = data.type;\n      var instanceCameras = data.instanceCameras;\n      var instanceControllers = data.instanceControllers;\n      var instanceLights = data.instanceLights;\n      var instanceGeometries = data.instanceGeometries;\n      var instanceNodes = data.instanceNodes; // nodes\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (var i = 0, l = instanceCameras.length; i < l; i++) {\n        var instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (var i = 0, l = instanceControllers.length; i < l; i++) {\n        var instance = instanceControllers[i];\n        var controller = getController(instance.id);\n        var geometries = getGeometry(controller.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n        var skeletons = instance.skeletons;\n        var joints = controller.skin.joints;\n        var skeleton = buildSkeleton(skeletons, joints);\n\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          var object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (var i = 0, l = instanceLights.length; i < l; i++) {\n        var instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (var i = 0, l = instanceGeometries.length; i < l; i++) {\n        var instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        var geometries = getGeometry(instance.id);\n        var newObjects = buildObjects(geometries, instance.materials);\n\n        for (var j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (var i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      var object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\n\n        for (var i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      if (object.name === '') {\n        object.name = type === 'JOINT' ? data.sid : data.name;\n      }\n\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    var fallbackMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      var materials = [];\n\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      var objects = [];\n\n      for (var type in geometries) {\n        var geometry = geometries[type];\n        var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new THREE.LineBasicMaterial());\n          } else {\n            materials.push(new THREE.MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        var skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        if (skinning) {\n          for (var i = 0, l = materials.length; i < l; i++) {\n            materials[i].skinning = true;\n          }\n        } // choose between a single or multi materials (material array)\n\n\n        var material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        var object;\n\n        switch (type) {\n          case 'lines':\n            object = new THREE.LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new THREE.Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new THREE.SkinnedMesh(geometry.data, material);\n            } else {\n              object = new THREE.Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      var data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      var elements = getElementsByTagName(xml, 'node');\n\n      for (var i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      var group = new THREE.Group();\n      group.name = data.name;\n      var children = data.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      var clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          var tracks = [];\n\n          for (var id in library.animations) {\n            var animationTracks = getAnimation(id);\n\n            for (var i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new THREE.AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (var id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new THREE.Scene()\n      };\n    }\n\n    var xml = new DOMParser().parseFromString(text, 'application/xml');\n    var collada = getElementsByTagName(xml, 'COLLADA')[0]; // metadata\n\n    var version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    var textureLoader = new THREE.TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var tgaLoader;\n\n    if (THREE.TGALoader) {\n      tgaLoader = new THREE.TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    var animations = [];\n    var kinematics = {};\n    var count = 0; //\n\n    var library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      animations: animations,\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script"}