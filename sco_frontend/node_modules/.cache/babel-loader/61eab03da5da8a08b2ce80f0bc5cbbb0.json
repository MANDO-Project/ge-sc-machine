{"ast":null,"code":"var Sigma = function (e) {\n  var o = {};\n\n  function t(i) {\n    if (o[i]) return o[i].exports;\n    var a = o[i] = {\n      i: i,\n      l: !1,\n      exports: {}\n    };\n    return e[i].call(a.exports, a, a.exports, t), a.l = !0, a.exports;\n  }\n\n  return t.m = e, t.c = o, t.d = function (e, o, i) {\n    t.o(e, o) || Object.defineProperty(e, o, {\n      enumerable: !0,\n      get: i\n    });\n  }, t.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, t.t = function (e, o) {\n    if (1 & o && (e = t(e)), 8 & o) return e;\n    if (4 & o && \"object\" == typeof e && e && e.__esModule) return e;\n    var i = Object.create(null);\n    if (t.r(i), Object.defineProperty(i, \"default\", {\n      enumerable: !0,\n      value: e\n    }), 2 & o && \"string\" != typeof e) for (var a in e) {\n      t.d(i, a, function (o) {\n        return e[o];\n      }.bind(null, a));\n    }\n    return i;\n  }, t.n = function (e) {\n    var o = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return t.d(o, \"a\", o), o;\n  }, t.o = function (e, o) {\n    return Object.prototype.hasOwnProperty.call(e, o);\n  }, t.p = \"\", t(t.s = 158);\n}({\n  158: function _(e, o, t) {\n    \"use strict\";\n\n    t.r(o);\n    t(159), t(160), t(161), t(162), t(163), t(164), t(165), t(166), t(167), t(168), t(169), t(170), t(171), t(172), t(173), t(174), t(175);\n  },\n  159: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.curve = function (e, o, t, i, a) {\n          var l,\n              r = e.color,\n              s = a(\"prefix\") || \"\",\n              c = e[s + \"size\"] || 1,\n              n = a(\"edgeColor\"),\n              d = a(\"defaultNodeColor\"),\n              g = a(\"defaultEdgeColor\"),\n              u = o[s + \"size\"],\n              f = o[s + \"x\"],\n              v = o[s + \"y\"],\n              h = t[s + \"x\"],\n              y = t[s + \"y\"];\n          if (l = o.id === t.id ? sigma.utils.getSelfLoopControlPoints(f, v, u) : sigma.utils.getQuadraticControlPoint(f, v, h, y), !r) switch (n) {\n            case \"source\":\n              r = o.color || d;\n              break;\n\n            case \"target\":\n              r = t.color || d;\n              break;\n\n            default:\n              r = g;\n          }\n          i.strokeStyle = r, i.lineWidth = c, i.beginPath(), i.moveTo(f, v), o.id === t.id ? i.bezierCurveTo(l.x1, l.y1, l.x2, l.y2, h, y) : i.quadraticCurveTo(l.x, l.y, h, y), i.stroke();\n        };\n      }();\n    }).call(window);\n  },\n  160: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.arrow = function (e, o, t, i, a) {\n          var l = e.color,\n              r = a(\"prefix\") || \"\",\n              s = a(\"edgeColor\"),\n              c = a(\"defaultNodeColor\"),\n              n = a(\"defaultEdgeColor\"),\n              d = e[r + \"size\"] || 1,\n              g = t[r + \"size\"],\n              u = o[r + \"x\"],\n              f = o[r + \"y\"],\n              v = t[r + \"x\"],\n              h = t[r + \"y\"],\n              y = Math.max(2.5 * d, a(\"minArrowSize\")),\n              m = Math.sqrt(Math.pow(v - u, 2) + Math.pow(h - f, 2)),\n              x = u + (v - u) * (m - y - g) / m,\n              C = f + (h - f) * (m - y - g) / m,\n              b = (v - u) * y / m,\n              p = (h - f) * y / m;\n          if (!l) switch (s) {\n            case \"source\":\n              l = o.color || c;\n              break;\n\n            case \"target\":\n              l = t.color || c;\n              break;\n\n            default:\n              l = n;\n          }\n          i.strokeStyle = l, i.lineWidth = d, i.beginPath(), i.moveTo(u, f), i.lineTo(x, C), i.stroke(), i.fillStyle = l, i.beginPath(), i.moveTo(x + b, C + p), i.lineTo(x + .6 * p, C - .6 * b), i.lineTo(x - .6 * p, C + .6 * b), i.lineTo(x + b, C + p), i.closePath(), i.fill();\n        };\n      }();\n    }).call(window);\n  },\n  161: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.curvedArrow = function (e, o, t, i, a) {\n          var l,\n              r,\n              s,\n              c,\n              n,\n              d,\n              g = e.color,\n              u = a(\"prefix\") || \"\",\n              f = a(\"edgeColor\"),\n              v = a(\"defaultNodeColor\"),\n              h = a(\"defaultEdgeColor\"),\n              y = e[u + \"size\"] || 1,\n              m = t[u + \"size\"],\n              x = o[u + \"x\"],\n              C = o[u + \"y\"],\n              b = t[u + \"x\"],\n              p = t[u + \"y\"],\n              w = Math.max(2.5 * y, a(\"minArrowSize\"));\n          if (l = o.id === t.id ? sigma.utils.getSelfLoopControlPoints(x, C, m) : sigma.utils.getQuadraticControlPoint(x, C, b, p), o.id === t.id ? (r = Math.sqrt(Math.pow(b - l.x1, 2) + Math.pow(p - l.y1, 2)), s = l.x1 + (b - l.x1) * (r - w - m) / r, c = l.y1 + (p - l.y1) * (r - w - m) / r, n = (b - l.x1) * w / r, d = (p - l.y1) * w / r) : (r = Math.sqrt(Math.pow(b - l.x, 2) + Math.pow(p - l.y, 2)), s = l.x + (b - l.x) * (r - w - m) / r, c = l.y + (p - l.y) * (r - w - m) / r, n = (b - l.x) * w / r, d = (p - l.y) * w / r), !g) switch (f) {\n            case \"source\":\n              g = o.color || v;\n              break;\n\n            case \"target\":\n              g = t.color || v;\n              break;\n\n            default:\n              g = h;\n          }\n          i.strokeStyle = g, i.lineWidth = y, i.beginPath(), i.moveTo(x, C), o.id === t.id ? i.bezierCurveTo(l.x2, l.y2, l.x1, l.y1, s, c) : i.quadraticCurveTo(l.x, l.y, s, c), i.stroke(), i.fillStyle = g, i.beginPath(), i.moveTo(s + n, c + d), i.lineTo(s + .6 * d, c - .6 * n), i.lineTo(s - .6 * d, c + .6 * n), i.lineTo(s + n, c + d), i.closePath(), i.fill();\n        };\n      }();\n    }).call(window);\n  },\n  162: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.curve = function (e, o, t, i, a) {\n          var l,\n              r = e.color,\n              s = a(\"prefix\") || \"\",\n              c = a(\"edgeHoverSizeRatio\") * (e[s + \"size\"] || 1),\n              n = a(\"edgeColor\"),\n              d = a(\"defaultNodeColor\"),\n              g = a(\"defaultEdgeColor\"),\n              u = o[s + \"size\"],\n              f = o[s + \"x\"],\n              v = o[s + \"y\"],\n              h = t[s + \"x\"],\n              y = t[s + \"y\"];\n          if (l = o.id === t.id ? sigma.utils.getSelfLoopControlPoints(f, v, u) : sigma.utils.getQuadraticControlPoint(f, v, h, y), !r) switch (n) {\n            case \"source\":\n              r = o.color || d;\n              break;\n\n            case \"target\":\n              r = t.color || d;\n              break;\n\n            default:\n              r = g;\n          }\n          r = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || r : e.hover_color || a(\"defaultEdgeHoverColor\") || r, i.strokeStyle = r, i.lineWidth = c, i.beginPath(), i.moveTo(f, v), o.id === t.id ? i.bezierCurveTo(l.x1, l.y1, l.x2, l.y2, h, y) : i.quadraticCurveTo(l.x, l.y, h, y), i.stroke();\n        };\n      }();\n    }).call(window);\n  },\n  163: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.arrow = function (e, o, t, i, a) {\n          var l = e.color,\n              r = a(\"prefix\") || \"\",\n              s = a(\"edgeColor\"),\n              c = a(\"defaultNodeColor\"),\n              n = a(\"defaultEdgeColor\"),\n              d = e[r + \"size\"] || 1,\n              g = t[r + \"size\"],\n              u = o[r + \"x\"],\n              f = o[r + \"y\"],\n              v = t[r + \"x\"],\n              h = t[r + \"y\"],\n              y = 2.5 * (d = e.hover ? a(\"edgeHoverSizeRatio\") * d : d),\n              m = Math.sqrt(Math.pow(v - u, 2) + Math.pow(h - f, 2)),\n              x = u + (v - u) * (m - y - g) / m,\n              C = f + (h - f) * (m - y - g) / m,\n              b = (v - u) * y / m,\n              p = (h - f) * y / m;\n          if (!l) switch (s) {\n            case \"source\":\n              l = o.color || c;\n              break;\n\n            case \"target\":\n              l = t.color || c;\n              break;\n\n            default:\n              l = n;\n          }\n          l = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || l : e.hover_color || a(\"defaultEdgeHoverColor\") || l, i.strokeStyle = l, i.lineWidth = d, i.beginPath(), i.moveTo(u, f), i.lineTo(x, C), i.stroke(), i.fillStyle = l, i.beginPath(), i.moveTo(x + b, C + p), i.lineTo(x + .6 * p, C - .6 * b), i.lineTo(x - .6 * p, C + .6 * b), i.lineTo(x + b, C + p), i.closePath(), i.fill();\n        };\n      }();\n    }).call(window);\n  },\n  164: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.curvedArrow = function (e, o, t, i, a) {\n          var l,\n              r,\n              s,\n              c,\n              n,\n              d,\n              g,\n              u = e.color,\n              f = a(\"prefix\") || \"\",\n              v = a(\"edgeColor\"),\n              h = a(\"defaultNodeColor\"),\n              y = a(\"defaultEdgeColor\"),\n              m = a(\"edgeHoverSizeRatio\") * (e[f + \"size\"] || 1),\n              x = t[f + \"size\"],\n              C = o[f + \"x\"],\n              b = o[f + \"y\"],\n              p = t[f + \"x\"],\n              w = t[f + \"y\"];\n          if (l = o.id === t.id ? sigma.utils.getSelfLoopControlPoints(C, b, x) : sigma.utils.getQuadraticControlPoint(C, b, p, w), o.id === t.id ? (r = Math.sqrt(Math.pow(p - l.x1, 2) + Math.pow(w - l.y1, 2)), s = 2.5 * m, c = l.x1 + (p - l.x1) * (r - s - x) / r, n = l.y1 + (w - l.y1) * (r - s - x) / r, d = (p - l.x1) * s / r, g = (w - l.y1) * s / r) : (r = Math.sqrt(Math.pow(p - l.x, 2) + Math.pow(w - l.y, 2)), s = 2.5 * m, c = l.x + (p - l.x) * (r - s - x) / r, n = l.y + (w - l.y) * (r - s - x) / r, d = (p - l.x) * s / r, g = (w - l.y) * s / r), !u) switch (v) {\n            case \"source\":\n              u = o.color || h;\n              break;\n\n            case \"target\":\n              u = t.color || h;\n              break;\n\n            default:\n              u = y;\n          }\n          u = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || u : e.hover_color || a(\"defaultEdgeHoverColor\") || u, i.strokeStyle = u, i.lineWidth = m, i.beginPath(), i.moveTo(C, b), o.id === t.id ? i.bezierCurveTo(l.x2, l.y2, l.x1, l.y1, c, n) : i.quadraticCurveTo(l.x, l.y, c, n), i.stroke(), i.fillStyle = u, i.beginPath(), i.moveTo(c + d, n + g), i.lineTo(c + .6 * g, n - .6 * d), i.lineTo(c - .6 * g, n + .6 * d), i.lineTo(c + d, n + g), i.closePath(), i.fill();\n        };\n      }();\n    }).call(window);\n  },\n  165: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.dashed = function (e, o, t, i, a) {\n          var l = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              r = a(\"prefix\") || \"\",\n              s = e[r + \"size\"] || 1,\n              c = a(\"edgeColor\"),\n              n = a(\"defaultNodeColor\"),\n              d = a(\"defaultEdgeColor\");\n          if (!l) switch (c) {\n            case \"source\":\n              l = o.color || n;\n              break;\n\n            case \"target\":\n              l = t.color || n;\n              break;\n\n            default:\n              l = d;\n          }\n          l = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || l : e.hover_color || a(\"defaultEdgeHoverColor\") || l, s *= a(\"edgeHoverSizeRatio\"), i.save(), i.setLineDash([8, 3]), i.strokeStyle = l, i.lineWidth = s, i.beginPath(), i.moveTo(o[r + \"x\"], o[r + \"y\"]), i.lineTo(t[r + \"x\"], t[r + \"y\"]), i.stroke(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  166: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.dotted = function (e, o, t, i, a) {\n          var l = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              r = a(\"prefix\") || \"\",\n              s = e[r + \"size\"] || 1,\n              c = a(\"edgeColor\"),\n              n = a(\"defaultNodeColor\"),\n              d = a(\"defaultEdgeColor\");\n          if (!l) switch (c) {\n            case \"source\":\n              l = o.color || n;\n              break;\n\n            case \"target\":\n              l = t.color || n;\n              break;\n\n            default:\n              l = d;\n          }\n          l = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || l : e.hover_color || a(\"defaultEdgeHoverColor\") || l, s *= a(\"edgeHoverSizeRatio\"), i.save(), i.setLineDash([2]), i.strokeStyle = l, i.lineWidth = s, i.beginPath(), i.moveTo(o[r + \"x\"], o[r + \"y\"]), i.lineTo(t[r + \"x\"], t[r + \"y\"]), i.stroke(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  167: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.parallel = function (e, o, t, i, a) {\n          var l,\n              r,\n              s = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              c = a(\"prefix\") || \"\",\n              n = e[c + \"size\"] || 1,\n              d = a(\"edgeColor\"),\n              g = a(\"defaultNodeColor\"),\n              u = a(\"defaultEdgeColor\"),\n              f = o[c + \"x\"],\n              v = o[c + \"y\"],\n              h = t[c + \"x\"],\n              y = t[c + \"y\"],\n              m = sigma.utils.getDistance(f, v, h, y);\n          if (!s) switch (d) {\n            case \"source\":\n              s = o.color || g;\n              break;\n\n            case \"target\":\n              s = t.color || g;\n              break;\n\n            default:\n              s = u;\n          }\n          s = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || s : e.hover_color || a(\"defaultEdgeHoverColor\") || s, n *= a(\"edgeHoverSizeRatio\"), l = sigma.utils.getCircleIntersection(f, v, n, h, y, m), r = sigma.utils.getCircleIntersection(h, y, n, f, v, m), i.save(), i.strokeStyle = s, i.lineWidth = n, i.beginPath(), i.moveTo(l.xi, l.yi), i.lineTo(r.xi_prime, r.yi_prime), i.closePath(), i.stroke(), i.beginPath(), i.moveTo(l.xi_prime, l.yi_prime), i.lineTo(r.xi, r.yi), i.closePath(), i.stroke(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  168: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edgehovers\"), sigma.canvas.edgehovers.tapered = function (e, o, t, i, a) {\n          var l = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              r = e[(c = a(\"prefix\") || \"\") + \"size\"] || 1,\n              s = a(\"edgeColor\"),\n              c = a(\"prefix\") || \"\",\n              n = a(\"defaultNodeColor\"),\n              d = a(\"defaultEdgeColor\"),\n              g = o[c + \"x\"],\n              u = o[c + \"y\"],\n              f = t[c + \"x\"],\n              v = t[c + \"y\"],\n              h = sigma.utils.getDistance(g, u, f, v);\n          if (!l) switch (s) {\n            case \"source\":\n              l = o.color || n;\n              break;\n\n            case \"target\":\n              l = t.color || n;\n              break;\n\n            default:\n              l = d;\n          }\n          l = \"edge\" === a(\"edgeHoverColor\") ? e.hover_color || l : e.hover_color || a(\"defaultEdgeHoverColor\") || l, r *= a(\"edgeHoverSizeRatio\");\n          var y = sigma.utils.getCircleIntersection(g, u, r, f, v, h);\n          i.save(), i.globalAlpha = .65, i.fillStyle = l, i.beginPath(), i.moveTo(f, v), i.lineTo(y.xi, y.yi), i.lineTo(y.xi_prime, y.yi_prime), i.closePath(), i.fill(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  169: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.dashed = function (e, o, t, i, a) {\n          var l = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              r = a(\"prefix\") || \"\",\n              s = e[r + \"size\"] || 1,\n              c = a(\"edgeColor\"),\n              n = a(\"defaultNodeColor\"),\n              d = a(\"defaultEdgeColor\");\n          if (!l) switch (c) {\n            case \"source\":\n              l = o.color || n;\n              break;\n\n            case \"target\":\n              l = t.color || n;\n              break;\n\n            default:\n              l = d;\n          }\n          i.save(), e.active ? i.strokeStyle = \"edge\" === a(\"edgeActiveColor\") ? l || d : a(\"defaultEdgeActiveColor\") : i.strokeStyle = l, i.setLineDash([8, 3]), i.lineWidth = s, i.beginPath(), i.moveTo(o[r + \"x\"], o[r + \"y\"]), i.lineTo(t[r + \"x\"], t[r + \"y\"]), i.stroke(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  170: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.dotted = function (e, o, t, i, a) {\n          var l = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              r = a(\"prefix\") || \"\",\n              s = e[r + \"size\"] || 1,\n              c = a(\"edgeColor\"),\n              n = a(\"defaultNodeColor\"),\n              d = a(\"defaultEdgeColor\");\n          if (!l) switch (c) {\n            case \"source\":\n              l = o.color || n;\n              break;\n\n            case \"target\":\n              l = t.color || n;\n              break;\n\n            default:\n              l = d;\n          }\n          i.save(), e.active ? i.strokeStyle = \"edge\" === a(\"edgeActiveColor\") ? l || d : a(\"defaultEdgeActiveColor\") : i.strokeStyle = l, i.setLineDash([2]), i.lineWidth = s, i.beginPath(), i.moveTo(o[r + \"x\"], o[r + \"y\"]), i.lineTo(t[r + \"x\"], t[r + \"y\"]), i.stroke(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  171: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.parallel = function (e, o, t, i, a) {\n          var l,\n              r,\n              s = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              c = a(\"prefix\") || \"\",\n              n = e[c + \"size\"] || 1,\n              d = a(\"edgeColor\"),\n              g = a(\"defaultNodeColor\"),\n              u = a(\"defaultEdgeColor\"),\n              f = o[c + \"x\"],\n              v = o[c + \"y\"],\n              h = t[c + \"x\"],\n              y = t[c + \"y\"],\n              m = sigma.utils.getDistance(f, v, h, y);\n          if (!s) switch (d) {\n            case \"source\":\n              s = o.color || g;\n              break;\n\n            case \"target\":\n              s = t.color || g;\n              break;\n\n            default:\n              s = u;\n          }\n          l = sigma.utils.getCircleIntersection(f, v, n, h, y, m), r = sigma.utils.getCircleIntersection(h, y, n, f, v, m), i.save(), e.active ? i.strokeStyle = \"edge\" === a(\"edgeActiveColor\") ? s || u : a(\"defaultEdgeActiveColor\") : i.strokeStyle = s, i.lineWidth = n, i.beginPath(), i.moveTo(l.xi, l.yi), i.lineTo(r.xi_prime, r.yi_prime), i.closePath(), i.stroke(), i.beginPath(), i.moveTo(l.xi_prime, l.yi_prime), i.lineTo(r.xi, r.yi), i.closePath(), i.stroke(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  172: function _(e, o) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.canvas.edges\"), sigma.canvas.edges.tapered = function (e, o, t, i, a) {\n          var l = e.active ? e.active_color || a(\"defaultEdgeActiveColor\") : e.color,\n              r = e[(c = a(\"prefix\") || \"\") + \"size\"] || 1,\n              s = a(\"edgeColor\"),\n              c = a(\"prefix\") || \"\",\n              n = a(\"defaultNodeColor\"),\n              d = a(\"defaultEdgeColor\"),\n              g = o[c + \"x\"],\n              u = o[c + \"y\"],\n              f = t[c + \"x\"],\n              v = t[c + \"y\"],\n              h = sigma.utils.getDistance(g, u, f, v);\n          if (!l) switch (s) {\n            case \"source\":\n              l = o.color || n;\n              break;\n\n            case \"target\":\n              l = t.color || n;\n              break;\n\n            default:\n              l = d;\n          }\n          var y = sigma.utils.getCircleIntersection(g, u, r, f, v, h);\n          i.save(), e.active ? i.fillStyle = \"edge\" === a(\"edgeActiveColor\") ? l || d : a(\"defaultEdgeActiveColor\") : i.fillStyle = l, i.globalAlpha = .65, i.beginPath(), i.moveTo(f, v), i.lineTo(y.xi, y.yi), i.lineTo(y.xi_prime, y.yi_prime), i.closePath(), i.fill(), i.restore();\n        };\n      }();\n    }).call(window);\n  },\n  173: function _(e, o) {\n    (function () {\n      (function (e) {\n        \"use strict\";\n\n        if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n        sigma.utils.pkg(\"sigma.canvas.edges.labels\"), sigma.canvas.edges.labels.def = function (e, o, t, i, a) {\n          if (\"string\" == typeof e.label && o != t) {\n            var l = a(\"prefix\") || \"\",\n                r = e[l + \"size\"] || 1;\n\n            if (!(r < a(\"edgeLabelThreshold\"))) {\n              if (0 === a(\"edgeLabelSizePowRatio\")) throw '\"edgeLabelSizePowRatio\" must not be 0.';\n              var s,\n                  c = (o[l + \"x\"] + t[l + \"x\"]) / 2,\n                  n = (o[l + \"y\"] + t[l + \"y\"]) / 2,\n                  d = t[l + \"x\"] - o[l + \"x\"],\n                  g = t[l + \"y\"] - o[l + \"y\"],\n                  u = o[l + \"x\"] < t[l + \"x\"] ? 1 : -1,\n                  f = Math.atan2(g * u, d * u);\n              s = \"fixed\" === a(\"edgeLabelSize\") ? a(\"defaultEdgeLabelSize\") : a(\"defaultEdgeLabelSize\") * r * Math.pow(r, -1 / a(\"edgeLabelSizePowRatio\")), i.save(), e.active ? (i.font = [a(\"activeFontStyle\"), s + \"px\", a(\"activeFont\") || a(\"font\")].join(\" \"), i.fillStyle = \"edge\" === a(\"edgeActiveColor\") ? e.active_color || a(\"defaultEdgeActiveColor\") : a(\"defaultEdgeLabelActiveColor\")) : (i.font = [a(\"fontStyle\"), s + \"px\", a(\"font\")].join(\" \"), i.fillStyle = \"edge\" === a(\"edgeLabelColor\") ? e.color || a(\"defaultEdgeColor\") : a(\"defaultEdgeLabelColor\")), i.textAlign = \"center\", i.textBaseline = \"alphabetic\", i.translate(c, n), i.rotate(f), i.fillText(e.label, 0, -r / 2 - 3), i.restore();\n            }\n          }\n        };\n      }).call(this);\n    }).call(window);\n  },\n  174: function _(e, o) {\n    (function () {\n      (function (e) {\n        \"use strict\";\n\n        if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n        sigma.utils.pkg(\"sigma.canvas.edges.labels\"), sigma.canvas.edges.labels.curve = function (e, o, t, i, a) {\n          if (\"string\" == typeof e.label) {\n            var l = a(\"prefix\") || \"\",\n                r = e[l + \"size\"] || 1;\n\n            if (!(r < a(\"edgeLabelThreshold\"))) {\n              var s,\n                  c,\n                  n,\n                  d = o[l + \"size\"],\n                  g = o[l + \"x\"],\n                  u = o[l + \"y\"],\n                  f = t[l + \"x\"],\n                  v = t[l + \"y\"],\n                  h = e.count || 0,\n                  y = f - g,\n                  m = v - u,\n                  x = g < f ? 1 : -1,\n                  C = {};\n              o.id === t.id ? (C = sigma.utils.getSelfLoopControlPoints(g, u, d, h), c = sigma.utils.getPointOnBezierCurve(.5, g, u, f, v, C.x1, C.y1, C.x2, C.y2), n = Math.atan2(1, 1)) : (C = sigma.utils.getQuadraticControlPoint(g, u, f, v, h), c = sigma.utils.getPointOnQuadraticCurve(.5, g, u, f, v, C.x, C.y), n = Math.atan2(m * x, y * x)), s = \"fixed\" === a(\"edgeLabelSize\") ? a(\"defaultEdgeLabelSize\") : a(\"defaultEdgeLabelSize\") * r * Math.pow(r, -1 / a(\"edgeLabelSizePowRatio\")), i.save(), e.active ? (i.font = [a(\"activeFontStyle\"), s + \"px\", a(\"activeFont\") || a(\"font\")].join(\" \"), i.fillStyle = \"edge\" === a(\"edgeActiveColor\") ? e.active_color || a(\"defaultEdgeActiveColor\") : a(\"defaultEdgeLabelActiveColor\")) : (i.font = [a(\"fontStyle\"), s + \"px\", a(\"font\")].join(\" \"), i.fillStyle = \"edge\" === a(\"edgeLabelColor\") ? e.color || a(\"defaultEdgeColor\") : a(\"defaultEdgeLabelColor\")), i.textAlign = \"center\", i.textBaseline = \"alphabetic\", i.translate(c.x, c.y), i.rotate(n), i.fillText(e.label, 0, -r / 2 - 3), i.restore();\n            }\n          }\n        };\n      }).call(this);\n    }).call(window);\n  },\n  175: function _(e, o) {\n    (function () {\n      (function (e) {\n        \"use strict\";\n\n        if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n        sigma.utils.pkg(\"sigma.canvas.edges.labels\"), sigma.canvas.edges.labels.curvedArrow = function (e, o, t, i, a) {\n          sigma.canvas.edges.labels.curve(e, o, t, i, a);\n        };\n      }).call(this);\n    }).call(window);\n  }\n});","map":null,"metadata":{},"sourceType":"script"}