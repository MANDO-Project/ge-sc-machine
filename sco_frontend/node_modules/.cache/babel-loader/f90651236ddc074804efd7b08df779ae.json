{"ast":null,"code":"/**\n * Movement Controls\n *\n * @author Don McCurdy <dm@donmccurdy.com>\n */\nvar COMPONENT_SUFFIX = '-controls',\n    MAX_DELTA = 0.2,\n    // ms\nEPS = 10e-6;\nmodule.exports = AFRAME.registerComponent('movement-controls', {\n  /*******************************************************************\n   * Schema\n   */\n  dependencies: ['rotation'],\n  schema: {\n    enabled: {\n      default: true\n    },\n    controls: {\n      default: ['gamepad', 'trackpad', 'keyboard', 'touch']\n    },\n    speed: {\n      default: 0.3,\n      min: 0\n    },\n    fly: {\n      default: false\n    },\n    constrainToNavMesh: {\n      default: false\n    },\n    camera: {\n      default: '[movement-controls] [camera]',\n      type: 'selector'\n    }\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n  init: function init() {\n    var el = this.el;\n    this.velocityCtrl = null;\n    this.velocity = new THREE.Vector3();\n    this.heading = new THREE.Quaternion(); // Navigation\n\n    this.navGroup = null;\n    this.navNode = null;\n\n    if (el.sceneEl.hasLoaded) {\n      this.injectControls();\n    } else {\n      el.sceneEl.addEventListener('loaded', this.injectControls.bind(this));\n    }\n  },\n  update: function update(prevData) {\n    var el = this.el;\n    var data = this.data;\n    var nav = el.sceneEl.systems.nav;\n\n    if (el.sceneEl.hasLoaded) {\n      this.injectControls();\n    }\n\n    if (nav && data.constrainToNavMesh !== prevData.constrainToNavMesh) {\n      data.constrainToNavMesh ? nav.addAgent(this) : nav.removeAgent(this);\n    }\n  },\n  injectControls: function injectControls() {\n    var data = this.data;\n    var name;\n\n    for (var i = 0; i < data.controls.length; i++) {\n      name = data.controls[i] + COMPONENT_SUFFIX;\n\n      if (!this.el.components[name]) {\n        this.el.setAttribute(name, '');\n      }\n    }\n  },\n  updateNavLocation: function updateNavLocation() {\n    this.navGroup = null;\n    this.navNode = null;\n  },\n\n  /*******************************************************************\n   * Tick\n   */\n  tick: function () {\n    var start = new THREE.Vector3();\n    var end = new THREE.Vector3();\n    var clampedEnd = new THREE.Vector3();\n    return function (t, dt) {\n      if (!dt) return;\n      var el = this.el;\n      var data = this.data;\n      if (!data.enabled) return;\n      this.updateVelocityCtrl();\n      var velocityCtrl = this.velocityCtrl;\n      var velocity = this.velocity;\n      if (!velocityCtrl) return; // Update velocity. If FPS is too low, reset.\n\n      if (dt / 1000 > MAX_DELTA) {\n        velocity.set(0, 0, 0);\n      } else {\n        this.updateVelocity(dt);\n      }\n\n      if (data.constrainToNavMesh && velocityCtrl.isNavMeshConstrained !== false) {\n        if (velocity.lengthSq() < EPS) return;\n        start.copy(el.object3D.position);\n        end.copy(velocity).multiplyScalar(dt / 1000).add(start);\n        var nav = el.sceneEl.systems.nav;\n        this.navGroup = this.navGroup === null ? nav.getGroup(start) : this.navGroup;\n        this.navNode = this.navNode || nav.getNode(start, this.navGroup);\n        this.navNode = nav.clampStep(start, end, this.navGroup, this.navNode, clampedEnd);\n        el.object3D.position.copy(clampedEnd);\n      } else if (el.hasAttribute('velocity')) {\n        el.setAttribute('velocity', velocity);\n      } else {\n        el.object3D.position.x += velocity.x * dt / 1000;\n        el.object3D.position.y += velocity.y * dt / 1000;\n        el.object3D.position.z += velocity.z * dt / 1000;\n      }\n    };\n  }(),\n\n  /*******************************************************************\n   * Movement\n   */\n  updateVelocityCtrl: function updateVelocityCtrl() {\n    var data = this.data;\n\n    if (data.enabled) {\n      for (var i = 0, l = data.controls.length; i < l; i++) {\n        var control = this.el.components[data.controls[i] + COMPONENT_SUFFIX];\n\n        if (control && control.isVelocityActive()) {\n          this.velocityCtrl = control;\n          return;\n        }\n      }\n\n      this.velocityCtrl = null;\n    }\n  },\n  updateVelocity: function () {\n    var vector2 = new THREE.Vector2();\n    var quaternion = new THREE.Quaternion();\n    return function (dt) {\n      var dVelocity;\n      var el = this.el;\n      var control = this.velocityCtrl;\n      var velocity = this.velocity;\n      var data = this.data;\n\n      if (control) {\n        if (control.getVelocityDelta) {\n          dVelocity = control.getVelocityDelta(dt);\n        } else if (control.getVelocity) {\n          velocity.copy(control.getVelocity());\n          return;\n        } else if (control.getPositionDelta) {\n          velocity.copy(control.getPositionDelta(dt).multiplyScalar(1000 / dt));\n          return;\n        } else {\n          throw new Error('Incompatible movement controls: ', control);\n        }\n      }\n\n      if (el.hasAttribute('velocity') && !data.constrainToNavMesh) {\n        velocity.copy(this.el.getAttribute('velocity'));\n      }\n\n      if (dVelocity && data.enabled) {\n        var cameraEl = data.camera; // Rotate to heading\n\n        quaternion.copy(cameraEl.object3D.quaternion);\n        quaternion.premultiply(el.object3D.quaternion);\n        dVelocity.applyQuaternion(quaternion);\n        var factor = dVelocity.length();\n\n        if (data.fly) {\n          velocity.copy(dVelocity);\n          velocity.multiplyScalar(this.data.speed * 16.66667);\n        } else {\n          vector2.set(dVelocity.x, dVelocity.z);\n          vector2.setLength(factor * this.data.speed * 16.66667);\n          velocity.x = vector2.x;\n          velocity.z = vector2.y;\n        }\n      }\n    };\n  }()\n});","map":null,"metadata":{},"sourceType":"script"}