{"ast":null,"code":"/**\n * Gamepad controls for A-Frame.\n *\n * Stripped-down version of: https://github.com/donmccurdy/aframe-gamepad-controls\n *\n * For more information about the Gamepad API, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\n */\nvar GamepadButton = require('../../lib/GamepadButton'),\n    GamepadButtonEvent = require('../../lib/GamepadButtonEvent');\n\nvar JOYSTICK_EPS = 0.2;\nvar Hand = {\n  LEFT: 'left',\n  RIGHT: 'right'\n};\nvar Joystick = {\n  MOVEMENT: 1,\n  ROTATION: 2\n};\nmodule.exports = AFRAME.registerComponent('gamepad-controls', {\n  /*******************************************************************\n   * Statics\n   */\n  GamepadButton: GamepadButton,\n\n  /*******************************************************************\n   * Schema\n   */\n  schema: {\n    // Enable/disable gamepad-controls\n    enabled: {\n      default: true\n    },\n    // Heading element for rotation\n    camera: {\n      default: '[camera]',\n      type: 'selector'\n    },\n    // Rotation sensitivity\n    rotationSensitivity: {\n      default: 2.0\n    }\n  },\n\n  /*******************************************************************\n   * Core\n   */\n\n  /**\n   * Called once when component is attached. Generally for initial setup.\n   */\n  init: function init() {\n    var sceneEl = this.el.sceneEl;\n    this.system = sceneEl.systems['tracked-controls-webxr'] || {\n      controllers: []\n    };\n    this.prevTime = window.performance.now(); // Button state\n\n    this.buttons = {}; // Rotation\n\n    var rotation = this.el.object3D.rotation;\n    this.pitch = new THREE.Object3D();\n    this.pitch.rotation.x = THREE.Math.degToRad(rotation.x);\n    this.yaw = new THREE.Object3D();\n    this.yaw.position.y = 10;\n    this.yaw.rotation.y = THREE.Math.degToRad(rotation.y);\n    this.yaw.add(this.pitch);\n    this._lookVector = new THREE.Vector2();\n    this._moveVector = new THREE.Vector2();\n    this._dpadVector = new THREE.Vector2();\n    sceneEl.addBehavior(this);\n  },\n\n  /**\n   * Called when component is attached and when component data changes.\n   * Generally modifies the entity based on the data.\n   */\n  update: function update() {\n    this.tick();\n  },\n\n  /**\n   * Called on each iteration of main render loop.\n   */\n  tick: function tick(t, dt) {\n    this.updateButtonState();\n    this.updateRotation(dt);\n  },\n\n  /**\n   * Called when a component is removed (e.g., via removeAttribute).\n   * Generally undoes all modifications to the entity.\n   */\n  remove: function remove() {},\n\n  /*******************************************************************\n   * Movement\n   */\n  isVelocityActive: function isVelocityActive() {\n    if (!this.data.enabled || !this.isConnected()) return false;\n    var dpad = this._dpadVector;\n    var joystick = this._moveVector;\n    this.getDpad(dpad);\n    this.getJoystick(Joystick.MOVEMENT, joystick);\n    var inputX = dpad.x || joystick.x;\n    var inputY = dpad.y || joystick.y;\n    return Math.abs(inputX) > JOYSTICK_EPS || Math.abs(inputY) > JOYSTICK_EPS;\n  },\n  getVelocityDelta: function getVelocityDelta() {\n    var dpad = this._dpadVector;\n    var joystick = this._moveVector;\n    this.getDpad(dpad);\n    this.getJoystick(Joystick.MOVEMENT, joystick);\n    var inputX = dpad.x || joystick.x;\n    var inputY = dpad.y || joystick.y;\n    var dVelocity = new THREE.Vector3();\n\n    if (Math.abs(inputX) > JOYSTICK_EPS) {\n      dVelocity.x += inputX;\n    }\n\n    if (Math.abs(inputY) > JOYSTICK_EPS) {\n      dVelocity.z += inputY;\n    }\n\n    return dVelocity;\n  },\n\n  /*******************************************************************\n   * Rotation\n   */\n  isRotationActive: function isRotationActive() {\n    if (!this.data.enabled || !this.isConnected()) return false;\n    var joystick = this._lookVector;\n    this.getJoystick(Joystick.ROTATION, joystick);\n    return Math.abs(joystick.x) > JOYSTICK_EPS || Math.abs(joystick.y) > JOYSTICK_EPS;\n  },\n  updateRotation: function updateRotation(dt) {\n    if (!this.isRotationActive()) return;\n    var data = this.data;\n    var yaw = this.yaw;\n    var pitch = this.pitch;\n    var lookControls = data.camera.components['look-controls'];\n    var hasLookControls = lookControls && lookControls.pitchObject && lookControls.yawObject; // Sync with look-controls pitch/yaw if available.\n\n    if (hasLookControls) {\n      pitch.rotation.copy(lookControls.pitchObject.rotation);\n      yaw.rotation.copy(lookControls.yawObject.rotation);\n    }\n\n    var lookVector = this._lookVector;\n    this.getJoystick(Joystick.ROTATION, lookVector);\n    if (Math.abs(lookVector.x) <= JOYSTICK_EPS) lookVector.x = 0;\n    if (Math.abs(lookVector.y) <= JOYSTICK_EPS) lookVector.y = 0;\n    lookVector.multiplyScalar(data.rotationSensitivity * dt / 1000);\n    yaw.rotation.y -= lookVector.x;\n    pitch.rotation.x -= lookVector.y;\n    pitch.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch.rotation.x));\n    data.camera.object3D.rotation.set(pitch.rotation.x, yaw.rotation.y, 0); // Sync with look-controls pitch/yaw if available.\n\n    if (hasLookControls) {\n      lookControls.pitchObject.rotation.copy(pitch.rotation);\n      lookControls.yawObject.rotation.copy(yaw.rotation);\n    }\n  },\n\n  /*******************************************************************\n   * Button events\n   */\n  updateButtonState: function updateButtonState() {\n    var gamepad = this.getGamepad(Hand.RIGHT);\n\n    if (this.data.enabled && gamepad) {\n      // Fire DOM events for button state changes.\n      for (var i = 0; i < gamepad.buttons.length; i++) {\n        if (gamepad.buttons[i].pressed && !this.buttons[i]) {\n          this.emit(new GamepadButtonEvent('gamepadbuttondown', i, gamepad.buttons[i]));\n        } else if (!gamepad.buttons[i].pressed && this.buttons[i]) {\n          this.emit(new GamepadButtonEvent('gamepadbuttonup', i, gamepad.buttons[i]));\n        }\n\n        this.buttons[i] = gamepad.buttons[i].pressed;\n      }\n    } else if (Object.keys(this.buttons)) {\n      // Reset state if controls are disabled or controller is lost.\n      this.buttons = {};\n    }\n  },\n  emit: function emit(event) {\n    // Emit original event.\n    this.el.emit(event.type, event); // Emit convenience event, identifying button index.\n\n    this.el.emit(event.type + ':' + event.index, new GamepadButtonEvent(event.type, event.index, event));\n  },\n\n  /*******************************************************************\n   * Gamepad state\n   */\n\n  /**\n   * Returns the Gamepad instance attached to the component. If connected,\n   * a proxy-controls component may provide access to Gamepad input from a\n   * remote device.\n   *\n   * @param {string} handPreference\n   * @return {Gamepad}\n   */\n  getGamepad: function () {\n    var _xrGamepads = [];\n    var _empty = [];\n    return function (handPreference) {\n      // https://github.com/donmccurdy/aframe-proxy-controls\n      var proxyControls = this.el.sceneEl.components['proxy-controls'];\n      var proxyGamepad = proxyControls && proxyControls.isConnected() && proxyControls.getGamepad(0);\n      if (proxyGamepad) return proxyGamepad; // https://www.w3.org/TR/webxr/#dom-xrinputsource-handedness\n\n      _xrGamepads.length = 0;\n\n      for (var i = 0; i < this.system.controllers.length; i++) {\n        var xrController = this.system.controllers[i];\n        var xrGamepad = xrController ? xrController.gamepad : null;\n\n        _xrGamepads.push(xrGamepad);\n\n        if (xrGamepad && xrGamepad.handedness === handPreference) return xrGamepad;\n      } // https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/hand\n\n\n      var navGamepads = navigator.getGamepads ? navigator.getGamepads() : _empty;\n\n      for (var _i = 0; _i < navGamepads.length; _i++) {\n        var navGamepad = navGamepads[_i];\n        if (navGamepad && navGamepad.hand === handPreference) return navGamepad;\n      }\n\n      return _xrGamepads[0] || navGamepads[0];\n    };\n  }(),\n\n  /**\n   * Returns the state of the given button.\n   * @param  {number} index The button (0-N) for which to find state.\n   * @return {GamepadButton}\n   */\n  getButton: function getButton(index) {\n    return this.getGamepad(Hand.RIGHT).buttons[index];\n  },\n\n  /**\n   * Returns state of the given axis. Axes are labelled 0-N, where 0-1 will\n   * represent X/Y on the first joystick, and 2-3 X/Y on the second.\n   * @param  {number} index The axis (0-N) for which to find state.\n   * @return {number} On the interval [-1,1].\n   */\n  getAxis: function getAxis(index) {\n    return this.getGamepad(index > 1 ? Hand.RIGHT : Hand.LEFT).axes[index];\n  },\n\n  /**\n   * Returns the state of the specified joystick as a THREE.Vector2.\n   * @param  {Joystick} role\n   * @param  {THREE.Vector2} target\n   * @return {THREE.Vector2}\n   */\n  getJoystick: function getJoystick(index, target) {\n    var gamepad = this.getGamepad(index === Joystick.MOVEMENT ? Hand.LEFT : Hand.RIGHT);\n\n    if (gamepad.mapping === 'xr-standard') {\n      // See: https://github.com/donmccurdy/aframe-extras/issues/307\n      switch (index) {\n        case Joystick.MOVEMENT:\n          return target.set(gamepad.axes[2], gamepad.axes[3]);\n\n        case Joystick.ROTATION:\n          return target.set(gamepad.axes[0], gamepad.axes[1]);\n      }\n    } else {\n      switch (index) {\n        case Joystick.MOVEMENT:\n          return target.set(gamepad.axes[0], gamepad.axes[1]);\n\n        case Joystick.ROTATION:\n          return target.set(gamepad.axes[2], gamepad.axes[3]);\n      }\n    }\n\n    throw new Error('Unexpected joystick index \"%d\".', index);\n  },\n\n  /**\n   * Returns the state of the dpad as a THREE.Vector2.\n   * @param {THREE.Vector2} target\n   * @return {THREE.Vector2}\n   */\n  getDpad: function getDpad(target) {\n    var gamepad = this.getGamepad(Hand.LEFT);\n\n    if (!gamepad.buttons[GamepadButton.DPAD_RIGHT]) {\n      return target.set(0, 0);\n    }\n\n    return target.set((gamepad.buttons[GamepadButton.DPAD_RIGHT].pressed ? 1 : 0) + (gamepad.buttons[GamepadButton.DPAD_LEFT].pressed ? -1 : 0), (gamepad.buttons[GamepadButton.DPAD_UP].pressed ? -1 : 0) + (gamepad.buttons[GamepadButton.DPAD_DOWN].pressed ? 1 : 0));\n  },\n\n  /**\n   * Returns true if the gamepad is currently connected to the system.\n   * @return {boolean}\n   */\n  isConnected: function isConnected() {\n    var gamepad = this.getGamepad(Hand.LEFT);\n    return !!(gamepad && gamepad.connected);\n  },\n\n  /**\n   * Returns a string containing some information about the controller. Result\n   * may vary across browsers, for a given controller.\n   * @return {string}\n   */\n  getID: function getID() {\n    return this.getGamepad(Hand.LEFT).id;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}