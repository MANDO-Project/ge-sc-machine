{"ast":null,"code":"var Sigma = function (e) {\n  var r = {};\n\n  function t(n) {\n    if (r[n]) return r[n].exports;\n    var o = r[n] = {\n      i: n,\n      l: !1,\n      exports: {}\n    };\n    return e[n].call(o.exports, o, o.exports, t), o.l = !0, o.exports;\n  }\n\n  return t.m = e, t.c = r, t.d = function (e, r, n) {\n    t.o(e, r) || Object.defineProperty(e, r, {\n      enumerable: !0,\n      get: n\n    });\n  }, t.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, t.t = function (e, r) {\n    if (1 & r && (e = t(e)), 8 & r) return e;\n    if (4 & r && \"object\" == typeof e && e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (t.r(n), Object.defineProperty(n, \"default\", {\n      enumerable: !0,\n      value: e\n    }), 2 & r && \"string\" != typeof e) for (var o in e) {\n      t.d(n, o, function (r) {\n        return e[r];\n      }.bind(null, o));\n    }\n    return n;\n  }, t.n = function (e) {\n    var r = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return t.d(r, \"a\", r), r;\n  }, t.o = function (e, r) {\n    return Object.prototype.hasOwnProperty.call(e, r);\n  }, t.p = \"\", t(t.s = 185);\n}({\n  185: function _(module, exports) {\n    (function () {\n      (function (undefined) {\n        \"use strict\";\n\n        if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n        sigma.utils.pkg(\"sigma.plugins\"), sigma.classes.graph.hasMethod(\"adjacentNodes\") || sigma.classes.graph.addMethod(\"adjacentNodes\", function (e) {\n          if (\"string\" != typeof e) throw \"adjacentNodes: the node id must be a string.\";\n          var r,\n              t = [];\n\n          for (r in this.allNeighborsIndex[e]) {\n            t.push(this.nodesIndex[r]);\n          }\n\n          return t;\n        }), sigma.classes.graph.hasMethod(\"adjacentEdges\") || sigma.classes.graph.addMethod(\"adjacentEdges\", function (e) {\n          if (\"string\" != typeof e) throw \"adjacentEdges: the node id must be a string.\";\n          var r,\n              t,\n              n = this.allNeighborsIndex[e],\n              o = [];\n\n          for (t in n) {\n            for (r in n[t]) {\n              o.push(n[t][r]);\n            }\n          }\n\n          return o;\n        });\n\n        var _g = undefined,\n            _s = undefined,\n            _chain = [],\n            _keysIndex = Object.create(null),\n            Processors = {};\n\n        function register(e, r, t) {\n          if (t != undefined && \"string\" != typeof t) throw 'The filter key \"' + t.toString() + '\" must be a string.';\n          if (t != undefined && !t.length) throw \"The filter key must be a non-empty string.\";\n          if (\"function\" != typeof e) throw 'The predicate of key \"' + t + '\" must be a function.';\n          if (\"undo\" === t) throw '\"undo\" is a reserved key.';\n          if (_keysIndex[t]) throw 'The filter \"' + t + '\" already exists.';\n          t && (_keysIndex[t] = !0), _chain.push({\n            key: t,\n            processor: e,\n            predicate: r\n          });\n        }\n\n        function unregister(e) {\n          for (var r in _chain = _chain.filter(function (r) {\n            return !(r.key in e);\n          }), e) {\n            delete _keysIndex[r];\n          }\n        }\n\n        function Filter(e) {\n          _s = e, _g = e.graph;\n        }\n\n        function deepCopy(o) {\n          var copy = Object.create(null);\n\n          for (var i in o) {\n            \"object\" == typeof o[i] && null !== o[i] ? copy[i] = deepCopy(o[i]) : \"function\" == typeof o[i] && null !== o[i] ? eval(\" copy[i] = \" + o[i].toString()) : copy[i] = o[i];\n          }\n\n          return copy;\n        }\n\n        function cloneChain(e) {\n          for (var r = e.slice(0), t = 0, n = r.length; t < n; t++) {\n            r[t] = deepCopy(r[t]), \"function\" == typeof r[t].processor && (r[t].processor = \"filter.processors.\" + r[t].processor.name);\n          }\n\n          return r;\n        }\n\n        Processors.nodes = function (e) {\n          for (var r = _g.nodes(), t = r.length, n = _g.edges(), o = n.length; t--;) {\n            r[t].hidden = !e.call(_g, r[t]) || r[t].hidden;\n          }\n\n          for (; o--;) {\n            (_g.nodes(n[o].source).hidden || _g.nodes(n[o].target).hidden) && (n[o].hidden = !0);\n          }\n        }, Processors.edges = function (e) {\n          for (var r = _g.edges(), t = r.length; t--;) {\n            r[t].hidden = !e.call(_g, r[t]) || r[t].hidden;\n          }\n        }, Processors.neighbors = function (e) {\n          for (var r = _g.nodes(), t = r.length, n = _g.edges(), o = n.length, i = _g.adjacentNodes(e), s = i.length, c = {}; s--;) {\n            c[i[s].id] = !0;\n          }\n\n          for (; t--;) {\n            r[t].id === e || r[t].id in c || (r[t].hidden = !0);\n          }\n\n          for (; o--;) {\n            (_g.nodes(n[o].source).hidden || _g.nodes(n[o].target).hidden) && (n[o].hidden = !0);\n          }\n        }, Filter.prototype.nodesBy = function (e, r) {\n          return register(Processors.nodes, e, r), this;\n        }, Filter.prototype.edgesBy = function (e, r) {\n          return register(Processors.edges, e, r), this;\n        }, Filter.prototype.neighborsOf = function (e, r) {\n          if (\"string\" != typeof e) throw 'The node id \"' + e.toString() + '\" must be a string.';\n          if (!e.length) throw \"The node id must be a non-empty string.\";\n          return register(Processors.neighbors, e, r), this;\n        }, Filter.prototype.apply = function () {\n          for (var e = 0, r = _chain.length; e < r; ++e) {\n            _chain[e].processor(_chain[e].predicate);\n          }\n\n          return _chain[0] && \"undo\" === _chain[0].key && _chain.shift(), _s.refresh(), this;\n        }, Filter.prototype.undo = function (e) {\n          var r = Object.create(null),\n              t = arguments.length;\n          if (1 === t) {\n            if (\"[object Array]\" === Object.prototype.toString.call(e)) for (var n = 0, o = e.length; n < o; n++) {\n              r[e[n]] = !0;\n            } else r[e] = !0;\n          } else if (t > 1) for (n = 0; n < t; n++) {\n            r[arguments[n]] = !0;\n          } else this.clear();\n\n          function i() {\n            for (var e = _g.nodes(), r = e.length, t = _g.edges(), n = t.length; r--;) {\n              e[r].hidden = !1;\n            }\n\n            for (; n--;) {\n              t[n].hidden = !1;\n            }\n          }\n\n          return unregister(r), _chain.unshift({\n            key: \"undo\",\n            processor: i\n          }), this;\n        }, Filter.prototype.clear = function () {\n          return _chain.length = 0, _keysIndex = Object.create(null), this;\n        }, Filter.prototype.export = function () {\n          return cloneChain(_chain);\n        }, Filter.prototype.import = function (e) {\n          if (e === undefined) throw \"Wrong arguments.\";\n          if (\"[object Array]\" !== Object.prototype.toString.call(e)) throw 'The chain\" must be an array.';\n\n          for (var r = cloneChain(e), t = 0, n = r.length; t < n; t++) {\n            if (r[t].predicate === undefined || r[t].processor === undefined) throw \"Wrong arguments.\";\n            if (r[t].key != undefined && \"string\" != typeof r[t].key) throw 'The filter key \"' + r[t].key.toString() + '\" must be a string.';\n            if (\"function\" != typeof r[t].predicate) throw 'The predicate of key \"' + r[t].key + '\" must be a function.';\n            if (\"string\" != typeof r[t].processor) throw 'The processor of key \"' + r[t].key + '\" must be a string.';\n\n            switch (r[t].processor) {\n              case \"filter.processors.nodes\":\n                r[t].processor = Processors.nodes;\n                break;\n\n              case \"filter.processors.edges\":\n                r[t].processor = Processors.edges;\n                break;\n\n              case \"filter.processors.neighbors\":\n                r[t].processor = Processors.neighbors;\n                break;\n\n              default:\n                throw \"Unknown processor \" + r[t].processor;\n            }\n          }\n\n          return _chain = r, this;\n        };\n        var filter = null;\n\n        sigma.plugins.filter = function (e) {\n          return filter = new Filter(e);\n        };\n      }).call(this);\n    }).call(window);\n  }\n});","map":null,"metadata":{},"sourceType":"script"}