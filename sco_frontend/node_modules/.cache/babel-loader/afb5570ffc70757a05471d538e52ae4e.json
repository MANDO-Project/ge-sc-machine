{"ast":null,"code":"/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nvar EPS = 0.000001;\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n  schema: {\n    mass: {\n      default: 5\n    },\n    radius: {\n      default: 1.3\n    },\n    linearDamping: {\n      default: 0.05\n    },\n    enableSlopes: {\n      default: true\n    },\n    enableJumps: {\n      default: false\n    }\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n  init: function init() {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n    var el = this.el,\n        data = this.data,\n        position = new CANNON.Vec3().copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(new CANNON.Sphere(data.radius), new CANNON.Vec3(0, data.radius, 0));\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n  remove: function remove() {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function beforeStep(t, dt) {\n    if (!dt) return;\n    var el = this.el;\n    var data = this.data;\n    var body = this.body;\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n  step: function () {\n    var velocity = new THREE.Vector3(),\n        normalizedVelocity = new THREE.Vector3(),\n        currentSurfaceNormal = new THREE.Vector3(),\n        groundNormal = new THREE.Vector3();\n    return function (t, dt) {\n      if (!dt) return;\n      var body = this.body,\n          data = this.data,\n          didCollide = false,\n          height,\n          groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) {\n          continue;\n        }\n\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id ? Math.abs(contact.rj.y + contact.bj.position.y) : Math.abs(contact.ri.y + contact.bi.position.y);\n\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        } // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n\n\n        velocity.projectOnPlane(groundNormal);\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }(),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function raycastToGround(groundBody, groundNormal) {\n    var ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n    ray = new CANNON.Ray(vFrom, vTo);\n\n    ray._updateDirection(); // TODO - Report bug.\n\n\n    ray.intersectBody(groundBody);\n    if (!ray.hasHit) return groundNormal; // Compare ABS, in case we're projecting against the inside of the face.\n\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}