{"ast":null,"code":"var Sigma = function (t) {\n  var e = {};\n\n  function i(r) {\n    if (e[r]) return e[r].exports;\n    var o = e[r] = {\n      i: r,\n      l: !1,\n      exports: {}\n    };\n    return t[r].call(o.exports, o, o.exports, i), o.l = !0, o.exports;\n  }\n\n  return i.m = t, i.c = e, i.d = function (t, e, r) {\n    i.o(t, e) || Object.defineProperty(t, e, {\n      enumerable: !0,\n      get: r\n    });\n  }, i.r = function (t) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n  }, i.t = function (t, e) {\n    if (1 & e && (t = i(t)), 8 & e) return t;\n    if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n    var r = Object.create(null);\n    if (i.r(r), Object.defineProperty(r, \"default\", {\n      enumerable: !0,\n      value: t\n    }), 2 & e && \"string\" != typeof t) for (var o in t) {\n      i.d(r, o, function (e) {\n        return t[e];\n      }.bind(null, o));\n    }\n    return r;\n  }, i.n = function (t) {\n    var e = t && t.__esModule ? function () {\n      return t.default;\n    } : function () {\n      return t;\n    };\n    return i.d(e, \"a\", e), e;\n  }, i.o = function (t, e) {\n    return Object.prototype.hasOwnProperty.call(t, e);\n  }, i.p = \"\", i(i.s = 142);\n}({\n  142: function _(t, e, i) {\n    \"use strict\";\n\n    i.r(e);\n    i(143), i(144), i(145), i(146), i(147), i(148), i(149);\n  },\n  143: function _(t, e) {\n    (function () {\n      (function (t) {\n        \"use strict\";\n\n        if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n        sigma.utils.pkg(\"sigma.renderers\"), sigma.renderers.webgl = function (t, e, i, r) {\n          if (\"object\" != typeof r) throw \"sigma.renderers.webgl: Wrong arguments.\";\n          if (!(r.container instanceof HTMLElement)) throw \"Container not found.\";\n          var o, a, s, n;\n\n          for (sigma.classes.dispatcher.extend(this), this.jobs = {}, Object.defineProperty(this, \"conradId\", {\n            value: sigma.utils.id()\n          }), this.graph = t, this.camera = e, this.contexts = {}, this.domElements = {}, this.options = r, this.container = this.options.container, this.settings = \"object\" == typeof r.settings && r.settings ? i.embedObjects(r.settings) : i, this.options.prefix = this.camera.readPrefix, Object.defineProperty(this, \"nodePrograms\", {\n            value: {}\n          }), Object.defineProperty(this, \"edgePrograms\", {\n            value: {}\n          }), Object.defineProperty(this, \"nodeFloatArrays\", {\n            value: {}\n          }), Object.defineProperty(this, \"edgeFloatArrays\", {\n            value: {}\n          }), Object.defineProperty(this, \"edgeIndicesArrays\", {\n            value: {}\n          }), this.settings(r, \"batchEdgesDrawing\") ? (this.initDOM(\"canvas\", \"edges\", !0), this.initDOM(\"canvas\", \"nodes\", !0)) : (this.initDOM(\"canvas\", \"scene\", !0), this.contexts.nodes = this.contexts.scene, this.contexts.edges = this.contexts.scene), this.initDOM(\"canvas\", \"labels\"), this.initDOM(\"canvas\", \"mouse\"), this.contexts.hover = this.contexts.mouse, this.captors = [], o = 0, a = (s = this.options.captors || [sigma.captors.mouse, sigma.captors.touch]).length; o < a; o++) {\n            n = \"function\" == typeof s[o] ? s[o] : sigma.captors[s[o]], this.captors.push(new n(this.domElements.mouse, this.camera, this.settings));\n          }\n\n          sigma.misc.bindEvents.call(this, this.camera.prefix), sigma.misc.drawHovers.call(this, this.camera.prefix), this.resize();\n        }, sigma.renderers.webgl.prototype.process = function () {\n          var t,\n              e,\n              i,\n              r,\n              o,\n              a,\n              s = this.graph,\n              n = sigma.utils.extend(n, this.options),\n              l = this.settings(n, \"defaultEdgeType\"),\n              c = this.settings(n, \"defaultNodeType\");\n\n          for (r in this.nodeFloatArrays) {\n            delete this.nodeFloatArrays[r];\n          }\n\n          for (r in this.edgeFloatArrays) {\n            delete this.edgeFloatArrays[r];\n          }\n\n          for (r in this.edgeIndicesArrays) {\n            delete this.edgeIndicesArrays[r];\n          }\n\n          for (e = 0, i = (t = s.edges()).length; e < i; e++) {\n            r = (o = t[e].type || l) && sigma.webgl.edges[o] ? o : \"def\", this.edgeFloatArrays[r] || (this.edgeFloatArrays[r] = {\n              edges: []\n            }), this.edgeFloatArrays[r].edges.push(t[e]);\n          }\n\n          for (e = 0, i = (t = s.nodes()).length; e < i; e++) {\n            r = (o = t[e].type || c) && sigma.webgl.nodes[o] ? o : \"def\", this.nodeFloatArrays[r] || (this.nodeFloatArrays[r] = {\n              nodes: []\n            }), this.nodeFloatArrays[r].nodes.push(t[e]);\n          }\n\n          for (r in this.edgeFloatArrays) {\n            for (a = sigma.webgl.edges[r], t = this.edgeFloatArrays[r].edges, this.edgeFloatArrays[r].array = new Float32Array(t.length * a.POINTS * a.ATTRIBUTES), e = 0, i = t.length; e < i; e++) {\n              t[e].hidden || s.nodes(t[e].source).hidden || s.nodes(t[e].target).hidden || a.addEdge(t[e], s.nodes(t[e].source), s.nodes(t[e].target), this.edgeFloatArrays[r].array, e * a.POINTS * a.ATTRIBUTES, n.prefix, this.settings);\n            }\n\n            \"function\" == typeof a.computeIndices && (this.edgeIndicesArrays[r] = a.computeIndices(this.edgeFloatArrays[r].array));\n          }\n\n          for (r in this.nodeFloatArrays) {\n            for (a = sigma.webgl.nodes[r], t = this.nodeFloatArrays[r].nodes, this.nodeFloatArrays[r].array = new Float32Array(t.length * a.POINTS * a.ATTRIBUTES), e = 0, i = t.length; e < i; e++) {\n              this.nodeFloatArrays[r].array || (this.nodeFloatArrays[r].array = new Float32Array(t.length * a.POINTS * a.ATTRIBUTES)), t[e].hidden || a.addNode(t[e], this.nodeFloatArrays[r].array, e * a.POINTS * a.ATTRIBUTES, n.prefix, this.settings);\n            }\n          }\n\n          return this;\n        }, sigma.renderers.webgl.prototype.render = function (e) {\n          var i,\n              r,\n              o,\n              a,\n              s,\n              n,\n              l = this,\n              c = (this.graph, this.contexts.nodes),\n              g = this.contexts.edges,\n              d = this.camera.getMatrix(),\n              u = sigma.utils.extend(e, this.options),\n              h = this.settings(u, \"drawLabels\"),\n              m = this.settings(u, \"drawEdges\"),\n              f = this.settings(u, \"drawNodes\");\n\n          for (a in this.resize(!1), this.settings(u, \"hideEdgesOnMove\") && (this.camera.isAnimated || this.camera.isMoving) && (m = !1), this.clear(), d = sigma.utils.matrices.multiply(d, sigma.utils.matrices.translation(this.width / 2, this.height / 2)), this.jobs) {\n            conrad.hasJob(a) && conrad.killJob(a);\n          }\n\n          if (m) if (this.settings(u, \"batchEdgesDrawing\")) (function () {\n            var t, e, i, r, o, a, s, n, l, c;\n            i = \"edges_\" + this.conradId, c = this.settings(u, \"webglEdgesBatchSize\"), (t = Object.keys(this.edgeFloatArrays)).length && (e = 0, l = sigma.webgl.edges[t[e]], o = this.edgeFloatArrays[t[e]].array, n = this.edgeIndicesArrays[t[e]], s = 0, a = Math.min(s + c * l.POINTS, o.length / l.ATTRIBUTES), r = function r() {\n              return this.edgePrograms[t[e]] || (this.edgePrograms[t[e]] = l.initProgram(g)), s < a && (g.useProgram(this.edgePrograms[t[e]]), l.render(g, this.edgePrograms[t[e]], o, {\n                settings: this.settings,\n                matrix: d,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(u, \"webglOversamplingRatio\"),\n                start: s,\n                count: a - s,\n                indicesData: n\n              })), a >= o.length / l.ATTRIBUTES && e === t.length - 1 ? (delete this.jobs[i], !1) : (a >= o.length / l.ATTRIBUTES ? (e++, o = this.edgeFloatArrays[t[e]].array, l = sigma.webgl.edges[t[e]], s = 0, a = Math.min(s + c * l.POINTS, o.length / l.ATTRIBUTES)) : (s = a, a = Math.min(s + c * l.POINTS, o.length / l.ATTRIBUTES)), !0);\n            }, this.jobs[i] = r, conrad.addJob(i, r.bind(this)));\n          }).call(this);else for (a in this.edgeFloatArrays) {\n            n = sigma.webgl.edges[a], this.edgePrograms[a] || (this.edgePrograms[a] = n.initProgram(g)), this.edgeFloatArrays[a] && (g.useProgram(this.edgePrograms[a]), n.render(g, this.edgePrograms[a], this.edgeFloatArrays[a].array, {\n              settings: this.settings,\n              matrix: d,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(u, \"webglOversamplingRatio\"),\n              indicesData: this.edgeIndicesArrays[a]\n            }));\n          }\n          if (f) for (a in c.blendFunc(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA), c.enable(c.BLEND), this.nodeFloatArrays) {\n            n = sigma.webgl.nodes[a], this.nodePrograms[a] || (this.nodePrograms[a] = n.initProgram(c)), this.nodeFloatArrays[a] && (c.useProgram(this.nodePrograms[a]), n.render(c, this.nodePrograms[a], this.nodeFloatArrays[a].array, {\n              settings: this.settings,\n              matrix: d,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(u, \"webglOversamplingRatio\")\n            }));\n          }\n          if (i = this.camera.quadtree.area(this.camera.getRectangle(this.width, this.height)), this.camera.applyView(t, t, {\n            nodes: i,\n            edges: [],\n            width: this.width,\n            height: this.height\n          }), h) for (s = function s(t) {\n            return l.settings({\n              prefix: l.camera.prefix\n            }, t);\n          }, r = 0, o = i.length; r < o; r++) {\n            i[r].hidden || (sigma.canvas.labels[i[r].type || this.settings(u, \"defaultNodeType\")] || sigma.canvas.labels.def)(i[r], this.contexts.labels, s);\n          }\n          return this.dispatchEvent(\"render\"), this;\n        }, sigma.renderers.webgl.prototype.initDOM = function (t, e, i) {\n          var r = document.createElement(t),\n              o = this;\n          r.style.position = \"absolute\", r.setAttribute(\"class\", \"sigma-\" + e), this.domElements[e] = r, this.container.appendChild(r), \"canvas\" === t.toLowerCase() && (this.contexts[e] = r.getContext(i ? \"experimental-webgl\" : \"2d\", {\n            preserveDrawingBuffer: !0\n          }), i && (r.addEventListener(\"webglcontextlost\", function (t) {\n            t.preventDefault();\n          }, !1), r.addEventListener(\"webglcontextrestored\", function (t) {\n            o.render();\n          }, !1)));\n        }, sigma.renderers.webgl.prototype.resize = function (e, i) {\n          var r,\n              o = this.width,\n              a = this.height,\n              s = sigma.utils.getPixelRatio();\n          if (e !== t && i !== t ? (this.width = e, this.height = i) : (this.width = this.container.offsetWidth, this.height = this.container.offsetHeight, e = this.width, i = this.height), o !== this.width || a !== this.height) for (r in this.domElements) {\n            this.domElements[r].style.width = e + \"px\", this.domElements[r].style.height = i + \"px\", \"canvas\" === this.domElements[r].tagName.toLowerCase() && (this.contexts[r] && this.contexts[r].scale ? (this.domElements[r].setAttribute(\"width\", e * s + \"px\"), this.domElements[r].setAttribute(\"height\", i * s + \"px\"), 1 !== s && this.contexts[r].scale(s, s)) : (this.domElements[r].setAttribute(\"width\", e * this.settings(\"webglOversamplingRatio\") + \"px\"), this.domElements[r].setAttribute(\"height\", i * this.settings(\"webglOversamplingRatio\") + \"px\")));\n          }\n\n          for (r in this.contexts) {\n            this.contexts[r] && this.contexts[r].viewport && this.contexts[r].viewport(0, 0, this.width * this.settings(\"webglOversamplingRatio\"), this.height * this.settings(\"webglOversamplingRatio\"));\n          }\n\n          return this;\n        }, sigma.renderers.webgl.prototype.clear = function () {\n          return this.contexts.labels.clearRect(0, 0, this.width, this.height), this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT), this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT), this;\n        }, sigma.renderers.webgl.prototype.kill = function () {\n          for (var t, e; e = this.captors.pop();) {\n            e.kill();\n          }\n\n          for (t in delete this.captors, this.domElements) {\n            this.domElements[t].parentNode.removeChild(this.domElements[t]), delete this.domElements[t], delete this.contexts[t];\n          }\n\n          delete this.domElements, delete this.contexts;\n        }, sigma.utils.pkg(\"sigma.webgl.nodes\"), sigma.utils.pkg(\"sigma.webgl.edges\"), sigma.utils.pkg(\"sigma.canvas.labels\");\n      }).call(this);\n    }).call(window);\n  },\n  144: function _(t, e) {\n    (function () {\n      !function (t) {\n        \"use strict\";\n\n        if (\"undefined\" == typeof sigma) throw \"sigma is not declared\";\n        sigma.utils.pkg(\"sigma.renderers\");\n        var e,\n            i = !!t.WebGLRenderingContext;\n\n        if (i) {\n          e = document.createElement(\"canvas\");\n\n          try {\n            i = !(!e.getContext(\"webgl\") && !e.getContext(\"experimental-webgl\"));\n          } catch (t) {\n            i = !1;\n          }\n        }\n\n        sigma.renderers.def = i ? sigma.renderers.webgl : sigma.renderers.canvas;\n      }(this);\n    }).call(window);\n  },\n  145: function _(t, e) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.webgl.nodes\"), sigma.webgl.nodes.def = {\n          POINTS: 3,\n          ATTRIBUTES: 5,\n          addNode: function addNode(t, e, i, r, o) {\n            var a = sigma.utils.floatColor(t.color || o(\"defaultNodeColor\"));\n            e[i++] = t[r + \"x\"], e[i++] = t[r + \"y\"], e[i++] = t[r + \"size\"], e[i++] = a, e[i++] = 0, e[i++] = t[r + \"x\"], e[i++] = t[r + \"y\"], e[i++] = t[r + \"size\"], e[i++] = a, e[i++] = 2 * Math.PI / 3, e[i++] = t[r + \"x\"], e[i++] = t[r + \"y\"], e[i++] = t[r + \"size\"], e[i++] = a, e[i++] = 4 * Math.PI / 3;\n          },\n          render: function render(t, e, i, r) {\n            var o,\n                a = t.getAttribLocation(e, \"a_position\"),\n                s = t.getAttribLocation(e, \"a_size\"),\n                n = t.getAttribLocation(e, \"a_color\"),\n                l = t.getAttribLocation(e, \"a_angle\"),\n                c = t.getUniformLocation(e, \"u_resolution\"),\n                g = t.getUniformLocation(e, \"u_matrix\"),\n                d = t.getUniformLocation(e, \"u_ratio\"),\n                u = t.getUniformLocation(e, \"u_scale\");\n            o = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, i, t.DYNAMIC_DRAW), t.uniform2f(c, r.width, r.height), t.uniform1f(d, 1 / Math.pow(r.ratio, r.settings(\"nodesPowRatio\"))), t.uniform1f(u, r.scalingRatio), t.uniformMatrix3fv(g, !1, r.matrix), t.enableVertexAttribArray(a), t.enableVertexAttribArray(s), t.enableVertexAttribArray(n), t.enableVertexAttribArray(l), t.vertexAttribPointer(a, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0), t.vertexAttribPointer(s, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8), t.vertexAttribPointer(n, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12), t.vertexAttribPointer(l, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16), t.drawArrays(t.TRIANGLES, r.start || 0, r.count || i.length / this.ATTRIBUTES);\n          },\n          initProgram: function initProgram(t) {\n            var e, i;\n            return e = sigma.utils.loadShader(t, [\"attribute vec2 a_position;\", \"attribute float a_size;\", \"attribute float a_color;\", \"attribute float a_angle;\", \"uniform vec2 u_resolution;\", \"uniform float u_ratio;\", \"uniform float u_scale;\", \"uniform mat3 u_matrix;\", \"varying vec4 color;\", \"varying vec2 center;\", \"varying float radius;\", \"void main() {\", \"radius = a_size * u_ratio;\", \"vec2 position = (u_matrix * vec3(a_position, 1)).xy;\", \"center = position * u_scale;\", \"center = vec2(center.x, u_scale * u_resolution.y - center.y);\", \"position = position +\", \"2.0 * radius * vec2(cos(a_angle), sin(a_angle));\", \"position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);\", \"radius = radius * u_scale;\", \"gl_Position = vec4(position, 0, 1);\", \"float c = a_color;\", \"color.b = mod(c, 256.0); c = floor(c / 256.0);\", \"color.g = mod(c, 256.0); c = floor(c / 256.0);\", \"color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;\", \"color.a = 1.0;\", \"}\"].join(\"\\n\"), t.VERTEX_SHADER), i = sigma.utils.loadShader(t, [\"precision mediump float;\", \"varying vec4 color;\", \"varying vec2 center;\", \"varying float radius;\", \"void main(void) {\", \"vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\", \"vec2 m = gl_FragCoord.xy - center;\", \"float diff = radius - sqrt(m.x * m.x + m.y * m.y);\", \"if (diff > 0.0)\", \"gl_FragColor = color;\", \"else\", \"gl_FragColor = color0;\", \"}\"].join(\"\\n\"), t.FRAGMENT_SHADER), sigma.utils.loadProgram(t, [e, i]);\n          }\n        };\n      }();\n    }).call(window);\n  },\n  146: function _(t, e) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.webgl.nodes\"), sigma.webgl.nodes.fast = {\n          POINTS: 1,\n          ATTRIBUTES: 4,\n          addNode: function addNode(t, e, i, r, o) {\n            e[i++] = t[r + \"x\"], e[i++] = t[r + \"y\"], e[i++] = t[r + \"size\"], e[i++] = sigma.utils.floatColor(t.color || o(\"defaultNodeColor\"));\n          },\n          render: function render(t, e, i, r) {\n            var o,\n                a = t.getAttribLocation(e, \"a_position\"),\n                s = t.getAttribLocation(e, \"a_size\"),\n                n = t.getAttribLocation(e, \"a_color\"),\n                l = t.getUniformLocation(e, \"u_resolution\"),\n                c = t.getUniformLocation(e, \"u_matrix\"),\n                g = t.getUniformLocation(e, \"u_ratio\"),\n                d = t.getUniformLocation(e, \"u_scale\");\n            o = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, i, t.DYNAMIC_DRAW), t.uniform2f(l, r.width, r.height), t.uniform1f(g, 1 / Math.pow(r.ratio, r.settings(\"nodesPowRatio\"))), t.uniform1f(d, r.scalingRatio), t.uniformMatrix3fv(c, !1, r.matrix), t.enableVertexAttribArray(a), t.enableVertexAttribArray(s), t.enableVertexAttribArray(n), t.vertexAttribPointer(a, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0), t.vertexAttribPointer(s, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8), t.vertexAttribPointer(n, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12), t.drawArrays(t.POINTS, r.start || 0, r.count || i.length / this.ATTRIBUTES);\n          },\n          initProgram: function initProgram(t) {\n            var e, i;\n            return e = sigma.utils.loadShader(t, [\"attribute vec2 a_position;\", \"attribute float a_size;\", \"attribute float a_color;\", \"uniform vec2 u_resolution;\", \"uniform float u_ratio;\", \"uniform float u_scale;\", \"uniform mat3 u_matrix;\", \"varying vec4 color;\", \"void main() {\", \"gl_Position = vec4(\", \"((u_matrix * vec3(a_position, 1)).xy /\", \"u_resolution * 2.0 - 1.0) * vec2(1, -1),\", \"0,\", \"1\", \");\", \"gl_PointSize = a_size * u_ratio * u_scale * 2.0;\", \"float c = a_color;\", \"color.b = mod(c, 256.0); c = floor(c / 256.0);\", \"color.g = mod(c, 256.0); c = floor(c / 256.0);\", \"color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;\", \"color.a = 1.0;\", \"}\"].join(\"\\n\"), t.VERTEX_SHADER), i = sigma.utils.loadShader(t, [\"precision mediump float;\", \"varying vec4 color;\", \"void main(void) {\", \"float border = 0.01;\", \"float radius = 0.5;\", \"vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\", \"vec2 m = gl_PointCoord - vec2(0.5, 0.5);\", \"float dist = radius - sqrt(m.x * m.x + m.y * m.y);\", \"float t = 0.0;\", \"if (dist > border)\", \"t = 1.0;\", \"else if (dist > 0.0)\", \"t = dist / border;\", \"gl_FragColor = mix(color0, color, t);\", \"}\"].join(\"\\n\"), t.FRAGMENT_SHADER), sigma.utils.loadProgram(t, [e, i]);\n          }\n        };\n      }();\n    }).call(window);\n  },\n  147: function _(t, e) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.webgl.edges\"), sigma.webgl.edges.def = {\n          POINTS: 6,\n          ATTRIBUTES: 7,\n          addEdge: function addEdge(t, e, i, r, o, a, s) {\n            var n = (t[a + \"size\"] || 1) / 2,\n                l = e[a + \"x\"],\n                c = e[a + \"y\"],\n                g = i[a + \"x\"],\n                d = i[a + \"y\"],\n                u = t.color;\n            if (!u) switch (s(\"edgeColor\")) {\n              case \"source\":\n                u = e.color || s(\"defaultNodeColor\");\n                break;\n\n              case \"target\":\n                u = i.color || s(\"defaultNodeColor\");\n                break;\n\n              default:\n                u = s(\"defaultEdgeColor\");\n            }\n            u = sigma.utils.floatColor(u), r[o++] = l, r[o++] = c, r[o++] = g, r[o++] = d, r[o++] = n, r[o++] = 0, r[o++] = u, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = 1, r[o++] = u, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = 0, r[o++] = u, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = 0, r[o++] = u, r[o++] = l, r[o++] = c, r[o++] = g, r[o++] = d, r[o++] = n, r[o++] = 1, r[o++] = u, r[o++] = l, r[o++] = c, r[o++] = g, r[o++] = d, r[o++] = n, r[o++] = 0, r[o++] = u;\n          },\n          render: function render(t, e, i, r) {\n            var o,\n                a = t.getAttribLocation(e, \"a_color\"),\n                s = t.getAttribLocation(e, \"a_position1\"),\n                n = t.getAttribLocation(e, \"a_position2\"),\n                l = t.getAttribLocation(e, \"a_thickness\"),\n                c = t.getAttribLocation(e, \"a_minus\"),\n                g = t.getUniformLocation(e, \"u_resolution\"),\n                d = t.getUniformLocation(e, \"u_matrix\"),\n                u = t.getUniformLocation(e, \"u_matrixHalfPi\"),\n                h = t.getUniformLocation(e, \"u_matrixHalfPiMinus\"),\n                m = t.getUniformLocation(e, \"u_ratio\"),\n                f = t.getUniformLocation(e, \"u_scale\");\n            o = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW), t.uniform2f(g, r.width, r.height), t.uniform1f(m, r.ratio / Math.pow(r.ratio, r.settings(\"edgesPowRatio\"))), t.uniform1f(f, r.scalingRatio), t.uniformMatrix3fv(d, !1, r.matrix), t.uniformMatrix2fv(u, !1, sigma.utils.matrices.rotation(Math.PI / 2, !0)), t.uniformMatrix2fv(h, !1, sigma.utils.matrices.rotation(-Math.PI / 2, !0)), t.enableVertexAttribArray(a), t.enableVertexAttribArray(s), t.enableVertexAttribArray(n), t.enableVertexAttribArray(l), t.enableVertexAttribArray(c), t.vertexAttribPointer(s, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0), t.vertexAttribPointer(n, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8), t.vertexAttribPointer(l, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16), t.vertexAttribPointer(c, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20), t.vertexAttribPointer(a, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24), t.drawArrays(t.TRIANGLES, r.start || 0, r.count || i.length / this.ATTRIBUTES);\n          },\n          initProgram: function initProgram(t) {\n            var e, i;\n            return e = sigma.utils.loadShader(t, [\"attribute vec2 a_position1;\", \"attribute vec2 a_position2;\", \"attribute float a_thickness;\", \"attribute float a_minus;\", \"attribute float a_color;\", \"uniform vec2 u_resolution;\", \"uniform float u_ratio;\", \"uniform float u_scale;\", \"uniform mat3 u_matrix;\", \"uniform mat2 u_matrixHalfPi;\", \"uniform mat2 u_matrixHalfPiMinus;\", \"varying vec4 color;\", \"void main() {\", \"vec2 position = a_thickness * u_ratio *\", \"normalize(a_position2 - a_position1);\", \"mat2 matrix = a_minus * u_matrixHalfPiMinus +\", \"(1.0 - a_minus) * u_matrixHalfPi;\", \"position = matrix * position + a_position1;\", \"gl_Position = vec4(\", \"((u_matrix * vec3(position, 1)).xy /\", \"u_resolution * 2.0 - 1.0) * vec2(1, -1),\", \"0,\", \"1\", \");\", \"float c = a_color;\", \"color.b = mod(c, 256.0); c = floor(c / 256.0);\", \"color.g = mod(c, 256.0); c = floor(c / 256.0);\", \"color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;\", \"color.a = 1.0;\", \"}\"].join(\"\\n\"), t.VERTEX_SHADER), i = sigma.utils.loadShader(t, [\"precision mediump float;\", \"varying vec4 color;\", \"void main(void) {\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\"), t.FRAGMENT_SHADER), sigma.utils.loadProgram(t, [e, i]);\n          }\n        };\n      }();\n    }).call(window);\n  },\n  148: function _(t, e) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.webgl.edges\"), sigma.webgl.edges.fast = {\n          POINTS: 2,\n          ATTRIBUTES: 3,\n          addEdge: function addEdge(t, e, i, r, o, a, s) {\n            t[a + \"size\"];\n            var n = e[a + \"x\"],\n                l = e[a + \"y\"],\n                c = i[a + \"x\"],\n                g = i[a + \"y\"],\n                d = t.color;\n            if (!d) switch (s(\"edgeColor\")) {\n              case \"source\":\n                d = e.color || s(\"defaultNodeColor\");\n                break;\n\n              case \"target\":\n                d = i.color || s(\"defaultNodeColor\");\n                break;\n\n              default:\n                d = s(\"defaultEdgeColor\");\n            }\n            d = sigma.utils.floatColor(d), r[o++] = n, r[o++] = l, r[o++] = d, r[o++] = c, r[o++] = g, r[o++] = d;\n          },\n          render: function render(t, e, i, r) {\n            var o,\n                a = t.getAttribLocation(e, \"a_color\"),\n                s = t.getAttribLocation(e, \"a_position\"),\n                n = t.getUniformLocation(e, \"u_resolution\"),\n                l = t.getUniformLocation(e, \"u_matrix\");\n            o = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, i, t.DYNAMIC_DRAW), t.uniform2f(n, r.width, r.height), t.uniformMatrix3fv(l, !1, r.matrix), t.enableVertexAttribArray(s), t.enableVertexAttribArray(a), t.vertexAttribPointer(s, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0), t.vertexAttribPointer(a, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8), t.lineWidth(3), t.drawArrays(t.LINES, r.start || 0, r.count || i.length / this.ATTRIBUTES);\n          },\n          initProgram: function initProgram(t) {\n            var e, i;\n            return e = sigma.utils.loadShader(t, [\"attribute vec2 a_position;\", \"attribute float a_color;\", \"uniform vec2 u_resolution;\", \"uniform mat3 u_matrix;\", \"varying vec4 color;\", \"void main() {\", \"gl_Position = vec4(\", \"((u_matrix * vec3(a_position, 1)).xy /\", \"u_resolution * 2.0 - 1.0) * vec2(1, -1),\", \"0,\", \"1\", \");\", \"float c = a_color;\", \"color.b = mod(c, 256.0); c = floor(c / 256.0);\", \"color.g = mod(c, 256.0); c = floor(c / 256.0);\", \"color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;\", \"color.a = 1.0;\", \"}\"].join(\"\\n\"), t.VERTEX_SHADER), i = sigma.utils.loadShader(t, [\"precision mediump float;\", \"varying vec4 color;\", \"void main(void) {\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\"), t.FRAGMENT_SHADER), sigma.utils.loadProgram(t, [e, i]);\n          }\n        };\n      }();\n    }).call(window);\n  },\n  149: function _(t, e) {\n    (function () {\n      !function () {\n        \"use strict\";\n\n        sigma.utils.pkg(\"sigma.webgl.edges\"), sigma.webgl.edges.arrow = {\n          POINTS: 9,\n          ATTRIBUTES: 11,\n          addEdge: function addEdge(t, e, i, r, o, a, s) {\n            var n = (t[a + \"size\"] || 1) / 2,\n                l = e[a + \"x\"],\n                c = e[a + \"y\"],\n                g = i[a + \"x\"],\n                d = i[a + \"y\"],\n                u = i[a + \"size\"],\n                h = t.color;\n            if (!h) switch (s(\"edgeColor\")) {\n              case \"source\":\n                h = e.color || s(\"defaultNodeColor\");\n                break;\n\n              case \"target\":\n                h = i.color || s(\"defaultNodeColor\");\n                break;\n\n              default:\n                h = s(\"defaultEdgeColor\");\n            }\n            h = sigma.utils.floatColor(h), r[o++] = l, r[o++] = c, r[o++] = g, r[o++] = d, r[o++] = n, r[o++] = u, r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = h, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = u, r[o++] = 1, r[o++] = 1, r[o++] = 0, r[o++] = 0, r[o++] = h, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = u, r[o++] = 1, r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = h, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = u, r[o++] = 1, r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = h, r[o++] = l, r[o++] = c, r[o++] = g, r[o++] = d, r[o++] = n, r[o++] = u, r[o++] = 0, r[o++] = 1, r[o++] = 0, r[o++] = 0, r[o++] = h, r[o++] = l, r[o++] = c, r[o++] = g, r[o++] = d, r[o++] = n, r[o++] = u, r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = 0, r[o++] = h, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = u, r[o++] = 1, r[o++] = 0, r[o++] = 1, r[o++] = -1, r[o++] = h, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = u, r[o++] = 1, r[o++] = 0, r[o++] = 1, r[o++] = 0, r[o++] = h, r[o++] = g, r[o++] = d, r[o++] = l, r[o++] = c, r[o++] = n, r[o++] = u, r[o++] = 1, r[o++] = 0, r[o++] = 1, r[o++] = 1, r[o++] = h;\n          },\n          render: function render(t, e, i, r) {\n            var o,\n                a = t.getAttribLocation(e, \"a_pos1\"),\n                s = t.getAttribLocation(e, \"a_pos2\"),\n                n = t.getAttribLocation(e, \"a_thickness\"),\n                l = t.getAttribLocation(e, \"a_tSize\"),\n                c = t.getAttribLocation(e, \"a_delay\"),\n                g = t.getAttribLocation(e, \"a_minus\"),\n                d = t.getAttribLocation(e, \"a_head\"),\n                u = t.getAttribLocation(e, \"a_headPosition\"),\n                h = t.getAttribLocation(e, \"a_color\"),\n                m = t.getUniformLocation(e, \"u_resolution\"),\n                f = t.getUniformLocation(e, \"u_matrix\"),\n                A = t.getUniformLocation(e, \"u_matrixHalfPi\"),\n                _ = t.getUniformLocation(e, \"u_matrixHalfPiMinus\"),\n                E = t.getUniformLocation(e, \"u_ratio\"),\n                T = t.getUniformLocation(e, \"u_nodeRatio\"),\n                b = t.getUniformLocation(e, \"u_arrowHead\"),\n                y = t.getUniformLocation(e, \"u_scale\");\n\n            o = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW), t.uniform2f(m, r.width, r.height), t.uniform1f(E, r.ratio / Math.pow(r.ratio, r.settings(\"edgesPowRatio\"))), t.uniform1f(T, Math.pow(r.ratio, r.settings(\"nodesPowRatio\")) / r.ratio), t.uniform1f(b, 5), t.uniform1f(y, r.scalingRatio), t.uniformMatrix3fv(f, !1, r.matrix), t.uniformMatrix2fv(A, !1, sigma.utils.matrices.rotation(Math.PI / 2, !0)), t.uniformMatrix2fv(_, !1, sigma.utils.matrices.rotation(-Math.PI / 2, !0)), t.enableVertexAttribArray(a), t.enableVertexAttribArray(s), t.enableVertexAttribArray(n), t.enableVertexAttribArray(l), t.enableVertexAttribArray(c), t.enableVertexAttribArray(g), t.enableVertexAttribArray(d), t.enableVertexAttribArray(u), t.enableVertexAttribArray(h), t.vertexAttribPointer(a, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0), t.vertexAttribPointer(s, 2, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8), t.vertexAttribPointer(n, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16), t.vertexAttribPointer(l, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20), t.vertexAttribPointer(c, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24), t.vertexAttribPointer(g, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 28), t.vertexAttribPointer(d, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 32), t.vertexAttribPointer(u, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 36), t.vertexAttribPointer(h, 1, t.FLOAT, !1, this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 40), t.drawArrays(t.TRIANGLES, r.start || 0, r.count || i.length / this.ATTRIBUTES);\n          },\n          initProgram: function initProgram(t) {\n            var e, i;\n            return e = sigma.utils.loadShader(t, [\"attribute vec2 a_pos1;\", \"attribute vec2 a_pos2;\", \"attribute float a_thickness;\", \"attribute float a_tSize;\", \"attribute float a_delay;\", \"attribute float a_minus;\", \"attribute float a_head;\", \"attribute float a_headPosition;\", \"attribute float a_color;\", \"uniform vec2 u_resolution;\", \"uniform float u_ratio;\", \"uniform float u_nodeRatio;\", \"uniform float u_arrowHead;\", \"uniform float u_scale;\", \"uniform mat3 u_matrix;\", \"uniform mat2 u_matrixHalfPi;\", \"uniform mat2 u_matrixHalfPiMinus;\", \"varying vec4 color;\", \"void main() {\", \"vec2 pos = normalize(a_pos2 - a_pos1);\", \"mat2 matrix = (1.0 - a_head) *\", \"(\", \"a_minus * u_matrixHalfPiMinus +\", \"(1.0 - a_minus) * u_matrixHalfPi\", \") + a_head * (\", \"a_headPosition * u_matrixHalfPiMinus * 0.6 +\", \"(a_headPosition * a_headPosition - 1.0) * mat2(1.0)\", \");\", \"pos = a_pos1 + (\", \"(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +\", \"a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +\", \"a_delay * pos * (\", \"a_tSize / u_nodeRatio +\", \"u_arrowHead * a_thickness * u_ratio\", \")\", \");\", \"gl_Position = vec4(\", \"((u_matrix * vec3(pos, 1)).xy /\", \"u_resolution * 2.0 - 1.0) * vec2(1, -1),\", \"0,\", \"1\", \");\", \"float c = a_color;\", \"color.b = mod(c, 256.0); c = floor(c / 256.0);\", \"color.g = mod(c, 256.0); c = floor(c / 256.0);\", \"color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;\", \"color.a = 1.0;\", \"}\"].join(\"\\n\"), t.VERTEX_SHADER), i = sigma.utils.loadShader(t, [\"precision mediump float;\", \"varying vec4 color;\", \"void main(void) {\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\"), t.FRAGMENT_SHADER), sigma.utils.loadProgram(t, [e, i]);\n          }\n        };\n      }();\n    }).call(window);\n  }\n});","map":null,"metadata":{},"sourceType":"script"}