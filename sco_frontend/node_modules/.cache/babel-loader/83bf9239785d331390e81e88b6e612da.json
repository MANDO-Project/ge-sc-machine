{"ast":null,"code":"var vg = module.exports = {\n  VERSION: \"0.1.1\",\n  PI: Math.PI,\n  TAU: 2 * Math.PI,\n  DEG_TO_RAD: .0174532925,\n  RAD_TO_DEG: 57.2957795,\n  SQRT3: Math.sqrt(3),\n  TILE: \"tile\",\n  ENT: \"entity\",\n  STR: \"structure\",\n  HEX: \"hex\",\n  SQR: \"square\",\n  ABS: \"abstract\"\n};\nvg.Board = function (e, t) {\n  if (!e) throw new Error(\"You must pass in a grid system for the board to use.\");\n  this.tiles = [], this.tileGroup = null, this.group = new THREE.Object3D(), this.grid = null, this.overlay = null, this.finder = new vg.AStarFinder(t), vg.Loader.init(), this.setGrid(e);\n}, vg.Board.prototype = {\n  setEntityOnTile: function setEntityOnTile(e, t) {\n    var i = this.grid.cellToPixel(t.cell);\n    e.position.copy(i), e.position.y += e.heightOffset || 0, e.tile && (e.tile.entity = null), e.tile = t, t.entity = e;\n  },\n  addTile: function addTile(e) {\n    var t = this.tiles.indexOf(e);\n    -1 === t && (this.tiles.push(e), this.snapTileToGrid(e), e.position.y = 0, this.tileGroup.add(e.mesh), this.grid.add(e.cell), e.cell.tile = e);\n  },\n  removeTile: function removeTile(e) {\n    if (e) {\n      var t = this.tiles.indexOf(e);\n      this.grid.remove(e.cell), -1 !== t && this.tiles.splice(t, 1), e.dispose();\n    }\n  },\n  removeAllTiles: function removeAllTiles() {\n    if (this.tileGroup) for (var e = this.tileGroup.children, t = 0; t < e.length; t++) {\n      this.tileGroup.remove(e[t]);\n    }\n  },\n  getTileAtCell: function getTileAtCell(e) {\n    var t = this.grid.cellToHash(e);\n    return e.tile || (\"undefined\" != typeof this.grid.cells[t] ? this.grid.cells[t].tile : null);\n  },\n  snapToGrid: function snapToGrid(e) {\n    var t = this.grid.pixelToCell(e);\n    e.copy(this.grid.cellToPixel(t));\n  },\n  snapTileToGrid: function snapTileToGrid(e) {\n    if (e.cell) e.position.copy(this.grid.cellToPixel(e.cell));else {\n      var t = this.grid.pixelToCell(e.position);\n      e.position.copy(this.grid.cellToPixel(t));\n    }\n    return e;\n  },\n  getRandomTile: function getRandomTile() {\n    var e = vg.Tools.randomInt(0, this.tiles.length - 1);\n    return this.tiles[e];\n  },\n  findPath: function findPath(e, t, i) {\n    return this.finder.findPath(e.cell, t.cell, i, this.grid);\n  },\n  setGrid: function setGrid(e) {\n    this.group.remove(this.tileGroup), this.grid && e !== this.grid && (this.removeAllTiles(), this.tiles.forEach(function (e) {\n      this.grid.remove(e.cell), e.dispose();\n    }), this.grid.dispose()), this.grid = e, this.tiles = [], this.tileGroup = new THREE.Object3D(), this.group.add(this.tileGroup);\n  },\n  generateOverlay: function generateOverlay(e) {\n    var t = new THREE.LineBasicMaterial({\n      color: 0,\n      opacity: .3\n    });\n    this.overlay && this.group.remove(this.overlay), this.overlay = new THREE.Object3D(), this.grid.generateOverlay(e, this.overlay, t), this.group.add(this.overlay);\n  },\n  generateTilemap: function generateTilemap(e) {\n    this.reset();\n    var t = this.grid.generateTiles(e);\n    this.tiles = t, this.tileGroup = new THREE.Object3D();\n\n    for (var i = 0; i < t.length; i++) {\n      this.tileGroup.add(t[i].mesh);\n    }\n\n    this.group.add(this.tileGroup);\n  },\n  reset: function reset() {\n    this.removeAllTiles(), this.tileGroup && this.group.remove(this.tileGroup);\n  }\n}, vg.Board.prototype.constructor = vg.Board, vg.Cell = function (e, t, i, s) {\n  this.q = e || 0, this.r = t || 0, this.s = i || 0, this.h = s || 1, this.tile = null, this.userData = {}, this.walkable = !0, this._calcCost = 0, this._priority = 0, this._visited = !1, this._parent = null, this.uniqueID = vg.LinkedList.generateID();\n}, vg.Cell.prototype = {\n  set: function set(e, t, i) {\n    return this.q = e, this.r = t, this.s = i, this;\n  },\n  copy: function copy(e) {\n    return this.q = e.q, this.r = e.r, this.s = e.s, this.h = e.h, this.tile = e.tile || null, this.userData = e.userData || {}, this.walkable = e.walkable, this;\n  },\n  add: function add(e) {\n    return this.q += e.q, this.r += e.r, this.s += e.s, this;\n  },\n  equals: function equals(e) {\n    return this.q === e.q && this.r === e.r && this.s === e.s;\n  }\n}, vg.Cell.prototype.constructor = vg.Cell, vg.HexGrid = function (e) {\n  e = e || {}, this.type = vg.HEX, this.size = 5, this.cellSize = \"undefined\" == typeof e.cellSize ? 10 : e.cellSize, this.cells = {}, this.numCells = 0, this.extrudeSettings = null, this.autogenerated = !1;\n  var t,\n      i = [];\n\n  for (t = 0; 6 > t; t++) {\n    i.push(this._createVertex(t));\n  }\n\n  for (this.cellShape = new THREE.Shape(), this.cellShape.moveTo(i[0].x, i[0].y), t = 1; 6 > t; t++) {\n    this.cellShape.lineTo(i[t].x, i[t].y);\n  }\n\n  this.cellShape.lineTo(i[0].x, i[0].y), this.cellShape.autoClose = !0, this.cellGeo = new THREE.Geometry(), this.cellGeo.vertices = i, this.cellGeo.verticesNeedUpdate = !0, this.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape), this._cellWidth = 2 * this.cellSize, this._cellLength = .5 * vg.SQRT3 * this._cellWidth, this._hashDelimeter = \".\", this._directions = [new vg.Cell(1, -1, 0), new vg.Cell(1, 0, -1), new vg.Cell(0, 1, -1), new vg.Cell(-1, 1, 0), new vg.Cell(-1, 0, 1), new vg.Cell(0, -1, 1)], this._diagonals = [new vg.Cell(2, -1, -1), new vg.Cell(1, 1, -2), new vg.Cell(-1, 2, -1), new vg.Cell(-2, 1, 1), new vg.Cell(-1, -1, 2), new vg.Cell(1, -2, 1)], this._list = [], this._vec3 = new THREE.Vector3(), this._cel = new vg.Cell(), this._conversionVec = new THREE.Vector3(), this._geoCache = [], this._matCache = [];\n}, vg.HexGrid.TWO_THIRDS = 2 / 3, vg.HexGrid.prototype = {\n  cellToPixel: function cellToPixel(e) {\n    return this._vec3.x = e.q * this._cellWidth * .75, this._vec3.y = e.h, this._vec3.z = -((e.s - e.r) * this._cellLength * .5), this._vec3;\n  },\n  pixelToCell: function pixelToCell(e) {\n    var t = e.x * (vg.HexGrid.TWO_THIRDS / this.cellSize),\n        i = (-e.x / 3 + vg.SQRT3 / 3 * e.z) / this.cellSize;\n    return this._cel.set(t, i, -t - i), this._cubeRound(this._cel);\n  },\n  getCellAt: function getCellAt(e) {\n    var t = e.x * (vg.HexGrid.TWO_THIRDS / this.cellSize),\n        i = (-e.x / 3 + vg.SQRT3 / 3 * e.z) / this.cellSize;\n    return this._cel.set(t, i, -t - i), this._cubeRound(this._cel), this.cells[this.cellToHash(this._cel)];\n  },\n  getNeighbors: function getNeighbors(e, t, i) {\n    var s,\n        n,\n        l = this._directions.length;\n\n    for (this._list.length = 0, s = 0; l > s; s++) {\n      this._cel.copy(e), this._cel.add(this._directions[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);\n    }\n\n    if (t) for (s = 0; l > s; s++) {\n      this._cel.copy(e), this._cel.add(this._diagonals[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);\n    }\n    return this._list;\n  },\n  getRandomCell: function getRandomCell() {\n    var e,\n        t = 0,\n        i = vg.Tools.randomInt(0, this.numCells);\n\n    for (e in this.cells) {\n      if (t === i) return this.cells[e];\n      t++;\n    }\n\n    return this.cells[e];\n  },\n  cellToHash: function cellToHash(e) {\n    return e.q + this._hashDelimeter + e.r + this._hashDelimeter + e.s;\n  },\n  distance: function distance(e, t) {\n    var i = Math.max(Math.abs(e.q - t.q), Math.abs(e.r - t.r), Math.abs(e.s - t.s));\n    return i += t.h - e.h;\n  },\n  clearPath: function clearPath() {\n    var e, t;\n\n    for (e in this.cells) {\n      t = this.cells[e], t._calcCost = 0, t._priority = 0, t._parent = null, t._visited = !1;\n    }\n  },\n  traverse: function traverse(e) {\n    var t;\n\n    for (t in this.cells) {\n      e(this.cells[t]);\n    }\n  },\n  generateTile: function generateTile(e, t, i) {\n    var s = Math.abs(e.h);\n    1 > s && (s = 1);\n    var n = this._geoCache[s];\n    n || (this.extrudeSettings.amount = s, n = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings), this._geoCache[s] = n);\n    var l = new vg.Tile({\n      size: this.cellSize,\n      scale: t,\n      cell: e,\n      geometry: n,\n      material: i\n    });\n    return e.tile = l, l;\n  },\n  generateTiles: function generateTiles(e) {\n    e = e || {};\n    var t = [],\n        i = {\n      tileScale: .95,\n      cellSize: this.cellSize,\n      material: null,\n      extrudeSettings: {\n        amount: 1,\n        bevelEnabled: !0,\n        bevelSegments: 1,\n        steps: 1,\n        bevelSize: .5,\n        bevelThickness: .5\n      }\n    };\n    i = vg.Tools.merge(i, e), this.cellSize = i.cellSize, this._cellWidth = 2 * this.cellSize, this._cellLength = .5 * vg.SQRT3 * this._cellWidth, this.autogenerated = !0, this.extrudeSettings = i.extrudeSettings;\n    var s, n, l;\n\n    for (s in this.cells) {\n      l = this.cells[s], n = this.generateTile(l, i.tileScale, i.material), n.position.copy(this.cellToPixel(l)), n.position.y = 0, t.push(n);\n    }\n\n    return t;\n  },\n  generateTilePoly: function generateTilePoly(e) {\n    e || (e = new THREE.MeshBasicMaterial({\n      color: 2405631\n    }));\n    var t = new THREE.Mesh(this.cellShapeGeo, e);\n    return this._vec3.set(1, 0, 0), t.rotateOnAxis(this._vec3, vg.PI / 2), t;\n  },\n  generate: function generate(e) {\n    e = e || {}, this.size = \"undefined\" == typeof e.size ? this.size : e.size;\n    var t, i, s, n;\n\n    for (t = -this.size; t < this.size + 1; t++) {\n      for (i = -this.size; i < this.size + 1; i++) {\n        s = -t - i, Math.abs(t) <= this.size && Math.abs(i) <= this.size && Math.abs(s) <= this.size && (n = new vg.Cell(t, i, s), this.add(n));\n      }\n    }\n  },\n  generateOverlay: function generateOverlay(e, t, i) {\n    var s,\n        n,\n        l,\n        r = this.cellShape.createPointsGeometry();\n\n    for (s = -e; e + 1 > s; s++) {\n      for (n = -e; e + 1 > n; n++) {\n        if (l = -s - n, Math.abs(s) <= e && Math.abs(n) <= e && Math.abs(l) <= e) {\n          this._cel.set(s, n, l);\n\n          var h = new THREE.Line(r, i);\n          h.position.copy(this.cellToPixel(this._cel)), h.rotation.x = 90 * vg.DEG_TO_RAD, t.add(h);\n        }\n      }\n    }\n  },\n  add: function add(e) {\n    var t = this.cellToHash(e);\n    if (!this.cells[t]) return this.cells[t] = e, this.numCells++, e;\n  },\n  remove: function remove(e) {\n    var t = this.cellToHash(e);\n    this.cells[t] && (delete this.cells[t], this.numCells--);\n  },\n  dispose: function dispose() {\n    this.cells = null, this.numCells = 0, this.cellShape = null, this.cellGeo.dispose(), this.cellGeo = null, this.cellShapeGeo.dispose(), this.cellShapeGeo = null, this._list = null, this._vec3 = null, this._conversionVec = null, this._geoCache = null, this._matCache = null;\n  },\n  load: function load(e, t, i) {\n    var s = this;\n    vg.Tools.getJSON({\n      url: e,\n      callback: function callback(e) {\n        s.fromJSON(e), t.call(i || null, e);\n      },\n      cache: !1,\n      scope: s\n    });\n  },\n  fromJSON: function fromJSON(e) {\n    var t,\n        i,\n        s = e.cells;\n\n    for (this.cells = {}, this.numCells = 0, this.size = e.size, this.cellSize = e.cellSize, this._cellWidth = 2 * this.cellSize, this._cellLength = .5 * vg.SQRT3 * this._cellWidth, this.extrudeSettings = e.extrudeSettings, this.autogenerated = e.autogenerated, t = 0; t < s.length; t++) {\n      i = new vg.Cell(), i.copy(s[t]), this.add(i);\n    }\n  },\n  toJSON: function toJSON() {\n    var e,\n        t,\n        i = {\n      size: this.size,\n      cellSize: this.cellSize,\n      extrudeSettings: this.extrudeSettings,\n      autogenerated: this.autogenerated\n    },\n        s = [];\n\n    for (t in this.cells) {\n      e = this.cells[t], s.push({\n        q: e.q,\n        r: e.r,\n        s: e.s,\n        h: e.h,\n        walkable: e.walkable,\n        userData: e.userData\n      });\n    }\n\n    return i.cells = s, i;\n  },\n  _createVertex: function _createVertex(e) {\n    var t = vg.TAU / 6 * e;\n    return new THREE.Vector3(this.cellSize * Math.cos(t), this.cellSize * Math.sin(t), 0);\n  },\n  _cubeRound: function _cubeRound(e) {\n    var t = Math.round(e.q),\n        i = Math.round(e.r),\n        s = Math.round(e.s),\n        n = Math.abs(t - e.q),\n        l = Math.abs(i - e.r),\n        r = Math.abs(s - e.s);\n    return n > l && n > r ? t = -i - s : l > r ? i = -t - s : s = -t - i, this._cel.set(t, i, s);\n  }\n}, vg.HexGrid.prototype.constructor = vg.HexGrid, vg.SqrGrid = function (e) {\n  e = e || {}, this.type = vg.SQR, this.size = 5, this.cellSize = \"undefined\" == typeof e.cellSize ? 10 : e.cellSize, this.cells = {}, this.numCells = 0, this.extrudeSettings = null, this.autogenerated = !1;\n  var t = [];\n  t.push(new THREE.Vector3()), t.push(new THREE.Vector3(-this.cellSize, this.cellSize)), t.push(new THREE.Vector3(this.cellSize, this.cellSize)), t.push(new THREE.Vector3(this.cellSize, -this.cellSize)), this.cellShape = new THREE.Shape(), this.cellShape.moveTo(-this.cellSize, -this.cellSize), this.cellShape.lineTo(-this.cellSize, this.cellSize), this.cellShape.lineTo(this.cellSize, this.cellSize), this.cellShape.lineTo(this.cellSize, -this.cellSize), this.cellShape.lineTo(-this.cellSize, -this.cellSize), this.cellGeo = new THREE.Geometry(), this.cellGeo.vertices = t, this.cellGeo.verticesNeedUpdate = !0, this.cellShapeGeo = new THREE.ShapeGeometry(this.cellShape), this._fullCellSize = 2 * this.cellSize, this._hashDelimeter = \".\", this._directions = [new vg.Cell(1, 0, 0), new vg.Cell(0, -1, 0), new vg.Cell(-1, 0, 0), new vg.Cell(0, 1, 0)], this._diagonals = [new vg.Cell(-1, -1, 0), new vg.Cell(-1, 1, 0), new vg.Cell(1, 1, 0), new vg.Cell(1, -1, 0)], this._list = [], this._vec3 = new THREE.Vector3(), this._cel = new vg.Cell(), this._conversionVec = new THREE.Vector3(), this._geoCache = [], this._matCache = [];\n}, vg.SqrGrid.prototype = {\n  cellToPixel: function cellToPixel(e) {\n    return this._vec3.x = e.q * this._fullCellSize, this._vec3.y = e.h, this._vec3.z = e.r * this._fullCellSize, this._vec3;\n  },\n  pixelToCell: function pixelToCell(e) {\n    var t = Math.round(e.x / this._fullCellSize),\n        i = Math.round(e.z / this._fullCellSize);\n    return this._cel.set(t, i, 0);\n  },\n  getCellAt: function getCellAt(e) {\n    var t = Math.round(e.x / this._fullCellSize),\n        i = Math.round(e.z / this._fullCellSize);\n    return this._cel.set(t, i), this.cells[this.cellToHash(this._cel)];\n  },\n  getNeighbors: function getNeighbors(e, t, i) {\n    var s,\n        n,\n        l = this._directions.length;\n\n    for (this._list.length = 0, s = 0; l > s; s++) {\n      this._cel.copy(e), this._cel.add(this._directions[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);\n    }\n\n    if (t) for (s = 0; l > s; s++) {\n      this._cel.copy(e), this._cel.add(this._diagonals[s]), n = this.cells[this.cellToHash(this._cel)], !n || i && !i(e, n) || this._list.push(n);\n    }\n    return this._list;\n  },\n  getRandomCell: function getRandomCell() {\n    var e,\n        t = 0,\n        i = vg.Tools.randomInt(0, this.numCells);\n\n    for (e in this.cells) {\n      if (t === i) return this.cells[e];\n      t++;\n    }\n\n    return this.cells[e];\n  },\n  cellToHash: function cellToHash(e) {\n    return e.q + this._hashDelimeter + e.r;\n  },\n  distance: function distance(e, t) {\n    var i = Math.max(Math.abs(e.q - t.q), Math.abs(e.r - t.r));\n    return i += t.h - e.h;\n  },\n  clearPath: function clearPath() {\n    var e, t;\n\n    for (e in this.cells) {\n      t = this.cells[e], t._calcCost = 0, t._priority = 0, t._parent = null, t._visited = !1;\n    }\n  },\n  traverse: function traverse(e) {\n    var t;\n\n    for (t in this.cells) {\n      e(this.cells[t]);\n    }\n  },\n  generateTile: function generateTile(e, t, i) {\n    var s = Math.abs(e.h);\n    1 > s && (s = 1);\n    var n = this._geoCache[s];\n    n || (this.extrudeSettings.amount = s, n = new THREE.ExtrudeGeometry(this.cellShape, this.extrudeSettings), this._geoCache[s] = n);\n    var l = new vg.Tile({\n      size: this.cellSize,\n      scale: t,\n      cell: e,\n      geometry: n,\n      material: i\n    });\n    return e.tile = l, l;\n  },\n  generateTiles: function generateTiles(e) {\n    e = e || {};\n    var t = [],\n        i = {\n      tileScale: .95,\n      cellSize: this.cellSize,\n      material: null,\n      extrudeSettings: {\n        amount: 1,\n        bevelEnabled: !0,\n        bevelSegments: 1,\n        steps: 1,\n        bevelSize: .5,\n        bevelThickness: .5\n      }\n    };\n    i = vg.Tools.merge(i, e), this.cellSize = i.cellSize, this._fullCellSize = 2 * this.cellSize, this.autogenerated = !0, this.extrudeSettings = i.extrudeSettings;\n    var s, n, l;\n\n    for (s in this.cells) {\n      l = this.cells[s], n = this.generateTile(l, i.tileScale, i.material), n.position.copy(this.cellToPixel(l)), n.position.y = 0, t.push(n);\n    }\n\n    return t;\n  },\n  generateTilePoly: function generateTilePoly(e) {\n    e || (e = new THREE.MeshBasicMaterial({\n      color: 2405631\n    }));\n    var t = new THREE.Mesh(this.cellShapeGeo, e);\n    return this._vec3.set(1, 0, 0), t.rotateOnAxis(this._vec3, vg.PI / 2), t;\n  },\n  generate: function generate(e) {\n    e = e || {}, this.size = \"undefined\" == typeof e.size ? this.size : e.size;\n    var t,\n        i,\n        s,\n        n = Math.ceil(this.size / 2);\n\n    for (t = -n; n > t; t++) {\n      for (i = -n; n > i; i++) {\n        s = new vg.Cell(t, i + 1), this.add(s);\n      }\n    }\n  },\n  generateOverlay: function generateOverlay(e, t, i) {\n    var s,\n        n,\n        l = Math.ceil(e / 2);\n\n    for (s = -l; l > s; s++) {\n      for (n = -l; l > n; n++) {\n        this._cel.set(s, n);\n\n        var r = new THREE.Line(this.cellGeo, i);\n        r.position.copy(this.cellToPixel(this._cel)), r.rotation.x = 90 * vg.DEG_TO_RAD, t.add(r);\n      }\n    }\n  },\n  add: function add(e) {\n    var t = this.cellToHash(e);\n    if (!this.cells[t]) return this.cells[t] = e, this.numCells++, e;\n  },\n  remove: function remove(e) {\n    var t = this.cellToHash(e);\n    this.cells[t] && (delete this.cells[t], this.numCells--);\n  },\n  dispose: function dispose() {\n    this.cells = null, this.numCells = 0, this.cellShape = null, this.cellGeo.dispose(), this.cellGeo = null, this.cellShapeGeo.dispose(), this.cellShapeGeo = null, this._list = null, this._vec3 = null, this._conversionVec = null, this._geoCache = null, this._matCache = null;\n  },\n  load: function load(e, t, i) {\n    vg.Tools.getJSON({\n      url: e,\n      callback: function callback(e) {\n        this.fromJSON(e), t.call(i || null, e);\n      },\n      cache: !1,\n      scope: this\n    });\n  },\n  fromJSON: function fromJSON(e) {\n    var t,\n        i,\n        s = e.cells;\n\n    for (this.cells = {}, this.numCells = 0, this.size = e.size, this.cellSize = e.cellSize, this._fullCellSize = 2 * this.cellSize, this.extrudeSettings = e.extrudeSettings, this.autogenerated = e.autogenerated, t = 0; t < s.length; t++) {\n      i = new vg.Cell(), i.copy(s[t]), this.add(i);\n    }\n  },\n  toJSON: function toJSON() {\n    var e,\n        t,\n        i = {\n      size: this.size,\n      cellSize: this.cellSize,\n      extrudeSettings: this.extrudeSettings,\n      autogenerated: this.autogenerated\n    },\n        s = [];\n\n    for (t in this.cells) {\n      e = this.cells[t], s.push({\n        q: e.q,\n        r: e.r,\n        s: e.s,\n        h: e.h,\n        walkable: e.walkable,\n        userData: e.userData\n      });\n    }\n\n    return i.cells = s, i;\n  }\n}, vg.SqrGrid.prototype.constructor = vg.SqrGrid, vg.Tile = function (e) {\n  e = e || {};\n  var t = {\n    cell: null,\n    geometry: null,\n    material: null\n  };\n  if (t = vg.Tools.merge(t, e), !t.cell || !t.geometry) throw new Error(\"Missing vg.Tile configuration\");\n  this.cell = t.cell, this.cell.tile && this.cell.tile !== this && this.cell.tile.dispose(), this.cell.tile = this, this.uniqueID = vg.Tools.generateID(), this.geometry = t.geometry, this.material = t.material, this.material || (this.material = new THREE.MeshPhongMaterial({\n    color: vg.Tools.randomizeRGB(\"30, 30, 30\", 13)\n  })), this.objectType = vg.TILE, this.entity = null, this.userData = {}, this.selected = !1, this.highlight = \"0x0084cc\", this.mesh = new THREE.Mesh(this.geometry, this.material), this.mesh.userData.structure = this, this.position = this.mesh.position, this.rotation = this.mesh.rotation, this.rotation.x = -90 * vg.DEG_TO_RAD, this.mesh.scale.set(t.scale, t.scale, 1), this.material.emissive ? this._emissive = this.material.emissive.getHex() : this._emissive = null;\n}, vg.Tile.prototype = {\n  select: function select() {\n    return this.material.emissive && this.material.emissive.setHex(this.highlight), this.selected = !0, this;\n  },\n  deselect: function deselect() {\n    return null !== this._emissive && this.material.emissive && this.material.emissive.setHex(this._emissive), this.selected = !1, this;\n  },\n  toggle: function toggle() {\n    return this.selected ? this.deselect() : this.select(), this;\n  },\n  dispose: function dispose() {\n    this.cell && this.cell.tile && (this.cell.tile = null), this.cell = null, this.position = null, this.rotation = null, this.mesh.parent && this.mesh.parent.remove(this.mesh), this.mesh.userData.structure = null, this.mesh = null, this.material = null, this.userData = null, this.entity = null, this.geometry = null, this._emissive = null;\n  }\n}, vg.Tile.prototype.constructor = vg.Tile, function () {\n  var e = function e() {\n    this.obj = null, this.next = null, this.prev = null, this.free = !0;\n  },\n      t = function t() {\n    this.first = null, this.last = null, this.length = 0, this.objToNodeMap = {}, this.uniqueID = Date.now() + \"\" + Math.floor(1e3 * Math.random()), this.sortArray = [];\n  };\n\n  t.generateID = function () {\n    return Math.random().toString(36).slice(2) + Date.now();\n  }, t.prototype = {\n    getNode: function getNode(e) {\n      return this.objToNodeMap[e.uniqueID];\n    },\n    addNode: function addNode(i) {\n      var s = new e();\n      if (!i.uniqueID) try {\n        i.uniqueID = t.generateID();\n      } catch (n) {\n        return console.error(\"[LinkedList.addNode] obj passed is immutable: cannot attach necessary identifier\"), null;\n      }\n      return s.obj = i, s.free = !1, this.objToNodeMap[i.uniqueID] = s, s;\n    },\n    swapObjects: function swapObjects(e, t) {\n      this.objToNodeMap[e.obj.uniqueID] = null, this.objToNodeMap[t.uniqueID] = e, e.obj = t;\n    },\n    add: function add(e) {\n      var t = this.objToNodeMap[e.uniqueID];\n\n      if (t) {\n        if (t.free === !1) return;\n        t.obj = e, t.free = !1, t.next = null, t.prev = null;\n      } else t = this.addNode(e);\n\n      if (this.first) {\n        if (!this.last) throw new Error(\"[LinkedList.add] No last in the list -- that shouldn't happen here\");\n        this.last.next = t, t.prev = this.last, this.last = t, t.next = null;\n      } else this.first = t, this.last = t, t.next = null, t.prev = null;\n\n      this.length++, this.showDebug && this.dump(\"after add\");\n    },\n    has: function has(e) {\n      return !!this.objToNodeMap[e.uniqueID];\n    },\n    moveUp: function moveUp(e) {\n      this.dump(\"before move up\");\n      var t = this.getNode(e);\n      if (!t) throw \"Oops, trying to move an object that isn't in the list\";\n\n      if (t.prev) {\n        var i = t.prev,\n            s = i.prev;\n        t == this.last && (this.last = i);\n        var n = t.next;\n        s && (s.next = t), t.next = i, t.prev = i.prev, i.next = n, i.prev = t, this.first == i && (this.first = t);\n      }\n    },\n    moveDown: function moveDown(e) {\n      var t = this.getNode(e);\n      if (!t) throw \"Oops, trying to move an object that isn't in the list\";\n\n      if (t.next) {\n        var i = t.next;\n        this.moveUp(i.obj), this.last == i && (this.last = t);\n      }\n    },\n    sort: function sort(e) {\n      var t,\n          i,\n          s = this.sortArray,\n          n = this.first;\n\n      for (s.length = 0; n;) {\n        s.push(n.obj), n = n.next;\n      }\n\n      for (this.clear(), s.sort(e), i = s.length, t = 0; i > t; t++) {\n        this.add(s[t]);\n      }\n    },\n    remove: function remove(e) {\n      var t = this.getNode(e);\n      return !t || t.free ? !1 : (t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.prev || (this.first = t.next), t.next || (this.last = t.prev), t.free = !0, t.prev = null, t.next = null, this.length--, !0);\n    },\n    shift: function shift() {\n      var e = this.first;\n      return 0 === this.length ? null : (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), this.first = e.next, e.next || (this.last = null), e.free = !0, e.prev = null, e.next = null, this.length--, e.obj);\n    },\n    pop: function pop() {\n      var e = this.last;\n      return 0 === this.length ? null : (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), this.last = e.prev, e.prev || (this.first = null), e.free = !0, e.prev = null, e.next = null, this.length--, e.obj);\n    },\n    concat: function concat(e) {\n      for (var t = e.first; t;) {\n        this.add(t.obj), t = t.next;\n      }\n    },\n    clear: function clear() {\n      for (var e = this.first; e;) {\n        e.free = !0, e = e.next;\n      }\n\n      this.first = null, this.length = 0;\n    },\n    dispose: function dispose() {\n      for (var e = this.first; e;) {\n        e.obj = null, e = e.next;\n      }\n\n      this.first = null, this.objToNodeMap = null;\n    },\n    dump: function dump(e) {\n      console.log(\"====================\" + e + \"=====================\");\n\n      for (var t = this.first; t;) {\n        console.log(\"{\" + t.obj.toString() + \"} previous=\" + (t.prev ? t.prev.obj : \"NULL\")), t = t.next();\n      }\n\n      console.log(\"===================================\"), console.log(\"Last: {\" + (this.last ? this.last.obj : \"NULL\") + \"} First: {\" + (this.first ? this.first.obj : \"NULL\") + \"}\");\n    }\n  }, t.prototype.constructor = t, vg.LinkedList = t;\n}(), function () {\n  var e = function e(_e, t, i, s, n) {\n    this._listener = t, this.isOnce = i, this.context = s, this.signal = _e, this._priority = n || 0;\n  };\n\n  e.prototype = {\n    active: !0,\n    params: null,\n    execute: function execute(e) {\n      var t, i;\n      return this.active && this._listener && (i = this.params ? this.params.concat(e) : e, t = this._listener.apply(this.context, i), this.isOnce && this.detach()), t;\n    },\n    detach: function detach() {\n      return this.isBound() ? this.signal.remove(this._listener, this.context) : null;\n    },\n    isBound: function isBound() {\n      return !!this.signal && !!this._listener;\n    },\n    _destroy: function _destroy() {\n      delete this.signal, delete this._listener, delete this.context;\n    },\n    toString: function toString() {\n      return \"[SignalBinding isOnce:\" + this.isOnce + \", isBound:\" + this.isBound() + \", active:\" + this.active + \"]\";\n    }\n  }, e.prototype.constructor = e;\n\n  var t = function t() {\n    this._bindings = [], this._prevParams = null;\n    var e = this;\n\n    this.dispatch = function () {\n      t.prototype.dispatch.apply(e, arguments);\n    };\n  };\n\n  t.prototype = {\n    memorize: !1,\n    _shouldPropagate: !0,\n    active: !0,\n    validateListener: function validateListener(e, t) {\n      if (\"function\" != typeof e) throw new Error(\"Signal: listener is a required param of {fn}() and should be a Function.\".replace(\"{fn}\", t));\n    },\n    _registerListener: function _registerListener(t, i, s, n) {\n      var l,\n          r = this._indexOfListener(t, s);\n\n      if (-1 !== r) {\n        if (l = this._bindings[r], l.isOnce !== i) throw new Error(\"You cannot add\" + (i ? \"\" : \"Once\") + \"() then add\" + (i ? \"Once\" : \"\") + \"() the same listener without removing the relationship first.\");\n      } else l = new e(this, t, i, s, n), this._addBinding(l);\n\n      return this.memorize && this._prevParams && l.execute(this._prevParams), l;\n    },\n    _addBinding: function _addBinding(e) {\n      var t = this._bindings.length;\n\n      do {\n        t--;\n      } while (this._bindings[t] && e._priority <= this._bindings[t]._priority);\n\n      this._bindings.splice(t + 1, 0, e);\n    },\n    _indexOfListener: function _indexOfListener(e, t) {\n      for (var i, s = this._bindings.length; s--;) {\n        if (i = this._bindings[s], i._listener === e && i.context === t) return s;\n      }\n\n      return -1;\n    },\n    has: function has(e, t) {\n      return -1 !== this._indexOfListener(e, t);\n    },\n    add: function add(e, t, i) {\n      return this.validateListener(e, \"add\"), this._registerListener(e, !1, t, i);\n    },\n    addOnce: function addOnce(e, t, i) {\n      return this.validateListener(e, \"addOnce\"), this._registerListener(e, !0, t, i);\n    },\n    remove: function remove(e, t) {\n      this.validateListener(e, \"remove\");\n\n      var i = this._indexOfListener(e, t);\n\n      return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), e;\n    },\n    removeAll: function removeAll(e) {\n      \"undefined\" == typeof e && (e = null);\n\n      for (var t = this._bindings.length; t--;) {\n        e ? this._bindings[t].context === e && (this._bindings[t]._destroy(), this._bindings.splice(t, 1)) : this._bindings[t]._destroy();\n      }\n\n      e || (this._bindings.length = 0);\n    },\n    getNumListeners: function getNumListeners() {\n      return this._bindings.length;\n    },\n    halt: function halt() {\n      this._shouldPropagate = !1;\n    },\n    dispatch: function dispatch() {\n      if (this.active) {\n        var e,\n            t = Array.prototype.slice.call(arguments),\n            i = this._bindings.length;\n\n        if (this.memorize && (this._prevParams = t), i) {\n          e = this._bindings.slice(), this._shouldPropagate = !0;\n\n          do {\n            i--;\n          } while (e[i] && this._shouldPropagate && e[i].execute(t) !== !1);\n        }\n      }\n    },\n    forget: function forget() {\n      this._prevParams = null;\n    },\n    dispose: function dispose() {\n      this.removeAll(), delete this._bindings, delete this._prevParams;\n    },\n    toString: function toString() {\n      return \"[Signal active:\" + this.active + \" numListeners:\" + this.getNumListeners() + \"]\";\n    }\n  }, t.prototype.constructor = t, vg.Signal = t;\n}(), vg.AStarFinder = function (e) {\n  e = e || {};\n  var t = {\n    allowDiagonal: !1,\n    heuristicFilter: null\n  };\n  t = vg.Tools.merge(t, e), this.allowDiagonal = t.allowDiagonal, this.heuristicFilter = t.heuristicFilter, this.list = new vg.LinkedList();\n}, vg.AStarFinder.prototype = {\n  findPath: function findPath(e, t, i, s) {\n    var n, l, r, h, o, a;\n\n    for (i = i || this.heuristicFilter, s.clearPath(), this.list.clear(), this.list.add(e); this.list.length > 0;) {\n      if (this.list.sort(this.compare), n = this.list.shift(), n._visited = !0, n === t) return vg.PathUtil.backtrace(t);\n\n      for (r = s.getNeighbors(n, this.allowDiagonal, i), o = 0, a = r.length; a > o; o++) {\n        if (h = r[o], h.walkable && (l = n._calcCost + s.distance(n, h), !h._visited || l < h._calcCost)) {\n          if (h._visited = !0, h._parent = n, h._calcCost = l, h._priority = l + s.distance(t, h), h === t) return vg.PathUtil.backtrace(t);\n          this.list.add(h);\n        }\n      }\n    }\n\n    return null;\n  },\n  compare: function compare(e, t) {\n    return e._priority - t._priority;\n  }\n}, vg.AStarFinder.prototype.constructor = vg.AStarFinder, vg.PathUtil = {\n  backtrace: function backtrace(e) {\n    for (var t = [e]; e._parent;) {\n      e = e._parent, t.push(e);\n    }\n\n    return t.reverse();\n  },\n  biBacktrace: function biBacktrace(e, t) {\n    var i = this.backtrace(e),\n        s = this.backtrace(t);\n    return i.concat(s.reverse());\n  },\n  pathLength: function pathLength(e) {\n    var t,\n        i,\n        s,\n        n,\n        l,\n        r = 0;\n\n    for (t = 1; t < e.length; ++t) {\n      i = e[t - 1], s = e[t], n = i[0] - s[0], l = i[1] - s[1], r += Math.sqrt(n * n + l * l);\n    }\n\n    return r;\n  },\n  interpolate: function interpolate(e, t, i, s) {\n    var n,\n        l,\n        r,\n        h,\n        o,\n        a,\n        c = Math.abs,\n        u = [];\n\n    for (r = c(i - e), h = c(s - t), n = i > e ? 1 : -1, l = s > t ? 1 : -1, o = r - h; e !== i || t !== s;) {\n      u.push([e, t]), a = 2 * o, a > -h && (o -= h, e += n), r > a && (o += r, t += l);\n    }\n\n    return u;\n  },\n  expandPath: function expandPath(e) {\n    var t,\n        i,\n        s,\n        n,\n        l,\n        r,\n        h = [],\n        o = e.length;\n    if (2 > o) return h;\n\n    for (l = 0; o - 1 > l; ++l) {\n      for (t = e[l], i = e[l + 1], s = this.interpolate(t[0], t[1], i[0], i[1]), n = s.length, r = 0; n - 1 > r; ++r) {\n        h.push(s[r]);\n      }\n    }\n\n    return h.push(e[o - 1]), h;\n  },\n  smoothenPath: function smoothenPath(e, t) {\n    var i,\n        s,\n        n,\n        l,\n        r,\n        h,\n        o,\n        a,\n        c,\n        u,\n        d,\n        g,\n        p = t.length,\n        v = t[0][0],\n        f = t[0][1],\n        m = t[p - 1][0],\n        _ = t[p - 1][1];\n\n    for (i = v, s = f, r = [[i, s]], o = 2; p > o; ++o) {\n      for (c = t[o], n = c[0], l = c[1], u = this.interpolate(i, s, n, l), g = !1, a = 1; a < u.length; ++a) {\n        if (d = u[a], !e.isWalkableAt(d[0], d[1])) {\n          g = !0;\n          break;\n        }\n      }\n\n      g && (h = t[o - 1], r.push(h), i = h[0], s = h[1]);\n    }\n\n    return r.push([m, _]), r;\n  },\n  compressPath: function compressPath(e) {\n    if (e.length < 3) return e;\n    var t,\n        i,\n        s,\n        n,\n        l,\n        r,\n        h = [],\n        o = e[0][0],\n        a = e[0][1],\n        c = e[1][0],\n        u = e[1][1],\n        d = c - o,\n        g = u - a;\n\n    for (l = Math.sqrt(d * d + g * g), d /= l, g /= l, h.push([o, a]), r = 2; r < e.length; r++) {\n      t = c, i = u, s = d, n = g, c = e[r][0], u = e[r][1], d = c - t, g = u - i, l = Math.sqrt(d * d + g * g), d /= l, g /= l, (d !== s || g !== n) && h.push([t, i]);\n    }\n\n    return h.push([c, u]), h;\n  }\n}, vg.Loader = {\n  manager: null,\n  imageLoader: null,\n  crossOrigin: !1,\n  init: function init(e) {\n    this.crossOrigin = e || !1, this.manager = new THREE.LoadingManager(function () {}, function () {}, function () {\n      console.warn(\"Error loading images\");\n    }), this.imageLoader = new THREE.ImageLoader(this.manager), this.imageLoader.crossOrigin = e;\n  },\n  loadTexture: function loadTexture(e, t, i, s) {\n    var n = new THREE.Texture(null, t);\n    return this.imageLoader.load(e, function (e) {\n      n.image = e, n.needsUpdate = !0, i && i(n);\n    }, null, function (e) {\n      s && s(e);\n    }), n.sourceFile = e, n;\n  }\n}, vg.MouseCaster = function (e, t, i) {\n  this.down = !1, this.rightDown = !1, this.pickedObject = null, this.selectedObject = null, this.allHits = null, this.active = !0, this.shift = !1, this.ctrl = !1, this.wheel = 0, this.position = new THREE.Vector3(), this.screenPosition = new THREE.Vector2(), this.signal = new vg.Signal(), this.group = e, this._camera = t, this._raycaster = new THREE.Raycaster(), this._preventDefault = !1, i = i || document, i.addEventListener(\"mousemove\", this._onDocumentMouseMove.bind(this), !1), i.addEventListener(\"mousedown\", this._onDocumentMouseDown.bind(this), !1), i.addEventListener(\"mouseup\", this._onDocumentMouseUp.bind(this), !1), i.addEventListener(\"mousewheel\", this._onMouseWheel.bind(this), !1), i.addEventListener(\"DOMMouseScroll\", this._onMouseWheel.bind(this), !1);\n}, vg.MouseCaster.OVER = \"over\", vg.MouseCaster.OUT = \"out\", vg.MouseCaster.DOWN = \"down\", vg.MouseCaster.UP = \"up\", vg.MouseCaster.CLICK = \"click\", vg.MouseCaster.WHEEL = \"wheel\", vg.MouseCaster.prototype = {\n  update: function update() {\n    if (this.active) {\n      this._raycaster.setFromCamera(this.screenPosition, this._camera);\n\n      var e,\n          t,\n          i = this._raycaster.intersectObject(this.group, !0);\n\n      i.length > 0 ? (e = i[0], t = e.object.userData.structure, this.pickedObject != t && (this.pickedObject && this.signal.dispatch(vg.MouseCaster.OUT, this.pickedObject), this.pickedObject = t, this.selectedObject = null, this.signal.dispatch(vg.MouseCaster.OVER, this.pickedObject)), this.position.copy(e.point), this.screenPosition.z = e.distance) : (this.pickedObject && this.signal.dispatch(vg.MouseCaster.OUT, this.pickedObject), this.pickedObject = null, this.selectedObject = null), this.allHits = i;\n    }\n  },\n  preventDefault: function preventDefault() {\n    this._preventDefault = !0;\n  },\n  _onDocumentMouseDown: function _onDocumentMouseDown(e) {\n    return e = e || window.event, e.preventDefault(), this._preventDefault ? (this._preventDefault = !1, !1) : (this.pickedObject && (this.selectedObject = this.pickedObject), this.shift = e.shiftKey, this.ctrl = e.ctrlKey, this.down = 1 === e.which, this.rightDown = 3 === e.which, void this.signal.dispatch(vg.MouseCaster.DOWN, this.pickedObject));\n  },\n  _onDocumentMouseUp: function _onDocumentMouseUp(e) {\n    return e.preventDefault(), this._preventDefault ? (this._preventDefault = !1, !1) : (this.shift = e.shiftKey, this.ctrl = e.ctrlKey, this.signal.dispatch(vg.MouseCaster.UP, this.pickedObject), this.selectedObject && this.pickedObject && this.selectedObject.uniqueID === this.pickedObject.uniqueID && this.signal.dispatch(vg.MouseCaster.CLICK, this.pickedObject), this.down = 1 === e.which ? !1 : this.down, void (this.rightDown = 3 === e.which ? !1 : this.rightDown));\n  },\n  _onDocumentMouseMove: function _onDocumentMouseMove(e) {\n    e.preventDefault(), this.screenPosition.x = e.clientX / window.innerWidth * 2 - 1, this.screenPosition.y = 2 * -(e.clientY / window.innerHeight) + 1;\n  },\n  _onMouseWheel: function _onMouseWheel(e) {\n    if (this.active) {\n      e.preventDefault(), e.stopPropagation();\n      var t = 0;\n      void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), t > 0 ? this.wheel++ : this.wheel--, this.signal.dispatch(vg.MouseCaster.WHEEL, this.wheel);\n    }\n  }\n}, vg.MouseCaster.prototype.constructor = vg.MouseCaster, vg.Scene = function (e, t) {\n  var i = {\n    element: document.body,\n    alpha: !0,\n    antialias: !0,\n    clearColor: \"#fff\",\n    sortObjects: !1,\n    fog: null,\n    light: new THREE.DirectionalLight(16777215),\n    lightPosition: null,\n    cameraType: \"PerspectiveCamera\",\n    cameraPosition: null,\n    orthoZoom: 4\n  },\n      s = {\n    minDistance: 100,\n    maxDistance: 1e3,\n    zoomSpeed: 2,\n    noZoom: !1\n  };\n\n  if (i = vg.Tools.merge(i, e), \"boolean\" != typeof t && (s = vg.Tools.merge(s, t)), this.renderer = new THREE.WebGLRenderer({\n    alpha: i.alpha,\n    antialias: i.antialias\n  }), this.renderer.setClearColor(i.clearColor, 0), this.renderer.sortObjects = i.sortObjects, this.width = window.innerWidth, this.height = window.innerHeight, this.orthoZoom = i.orthoZoom, this.container = new THREE.Scene(), this.container.fog = i.fog, this.container.add(new THREE.AmbientLight(14540253)), i.lightPosition || i.light.position.set(-1, 1, -1).normalize(), this.container.add(i.light), \"OrthographicCamera\" === i.cameraType) {\n    var n = window.innerWidth / this.orthoZoom,\n        l = window.innerHeight / this.orthoZoom;\n    this.camera = new THREE.OrthographicCamera(n / -2, n / 2, l / 2, l / -2, 1, 5e3);\n  } else this.camera = new THREE.PerspectiveCamera(50, this.width / this.height, 1, 5e3);\n\n  this.contolled = !!t, this.contolled && (this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement), this.controls.minDistance = s.minDistance, this.controls.maxDistance = s.maxDistance, this.controls.zoomSpeed = s.zoomSpeed, this.controls.noZoom = s.noZoom), i.cameraPosition && this.camera.position.copy(i.cameraPosition), window.addEventListener(\"resize\", function () {\n    if (this.width = window.innerWidth, this.height = window.innerHeight, \"OrthographicCamera\" === this.camera.type) {\n      var e = this.width / this.orthoZoom,\n          t = this.height / this.orthoZoom;\n      this.camera.left = e / -2, this.camera.right = e / 2, this.camera.top = t / 2, this.camera.bottom = t / -2;\n    } else this.camera.aspect = this.width / this.height;\n\n    this.camera.updateProjectionMatrix(), this.renderer.setSize(this.width, this.height);\n  }.bind(this), !1), this.attachTo(i.element);\n}, vg.Scene.prototype = {\n  attachTo: function attachTo(e) {\n    e.style.width = this.width + \"px\", e.style.height = this.height + \"px\", this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.width, this.height), e.appendChild(this.renderer.domElement);\n  },\n  add: function add(e) {\n    this.container.add(e);\n  },\n  remove: function remove(e) {\n    this.container.remove(e);\n  },\n  render: function render() {\n    this.contolled && this.controls.update(), this.renderer.render(this.container, this.camera);\n  },\n  updateOrthoZoom: function updateOrthoZoom() {\n    if (this.orthoZoom <= 0) return void (this.orthoZoom = 0);\n    var e = this.width / this.orthoZoom,\n        t = this.height / this.orthoZoom;\n    this.camera.left = e / -2, this.camera.right = e / 2, this.camera.top = t / 2, this.camera.bottom = t / -2, this.camera.updateProjectionMatrix();\n  },\n  focusOn: function focusOn(e) {\n    this.camera.lookAt(e.position);\n  }\n}, vg.Scene.prototype.constructor = vg.Scene, vg.SelectionManager = function (e) {\n  this.mouse = e, this.onSelect = new vg.Signal(), this.onDeselect = new vg.Signal(), this.selected = null, this.toggleSelection = !1, this.mouse.signal.add(this.onMouse, this);\n}, vg.SelectionManager.prototype = {\n  select: function select(e, t) {\n    e && (t = t || !0, this.selected !== e && this.clearSelection(t), e.selected ? this.toggleSelection && (t && this.onDeselect.dispatch(e), e.deselect()) : e.select(), this.selected = e, t && this.onSelect.dispatch(e));\n  },\n  clearSelection: function clearSelection(e) {\n    e = e || !0, this.selected && (e && this.onDeselect.dispatch(this.selected), this.selected.deselect()), this.selected = null;\n  },\n  onMouse: function onMouse(e, t) {\n    switch (e) {\n      case vg.MouseCaster.DOWN:\n        t || this.clearSelection();\n        break;\n\n      case vg.MouseCaster.CLICK:\n        this.select(t);\n    }\n  }\n}, vg.SelectionManager.prototype.constructor = vg.SelectionManager, vg.Tools = {\n  clamp: function clamp(e, t, i) {\n    return Math.max(t, Math.min(i, e));\n  },\n  sign: function sign(e) {\n    return e && e / Math.abs(e);\n  },\n  random: function random(e, t) {\n    return 1 === arguments.length ? Math.random() * e - .5 * e : Math.random() * (t - e) + e;\n  },\n  randomInt: function randomInt(e, t) {\n    return 1 === arguments.length ? Math.random() * e - .5 * e | 0 : Math.random() * (t - e + 1) + e | 0;\n  },\n  normalize: function normalize(e, t, i) {\n    return (e - t) / (i - t);\n  },\n  getShortRotation: function getShortRotation(e) {\n    return e %= this.TAU, e > this.PI ? e -= this.TAU : e < -this.PI && (e += this.TAU), e;\n  },\n  generateID: function generateID() {\n    return Math.random().toString(36).slice(2) + Date.now();\n  },\n  isPlainObject: function isPlainObject(e) {\n    if (\"object\" != typeof e || e.nodeType || e === e.window) return !1;\n\n    try {\n      if (e.constructor && !Object.prototype.hasOwnProperty.call(e.constructor.prototype, \"isPrototypeOf\")) return !1;\n    } catch (t) {\n      return !1;\n    }\n\n    return !0;\n  },\n  merge: function merge(e, t) {\n    var i = this,\n        s = Array.isArray(t),\n        n = s && [] || {};\n    return s ? (e = e || [], n = n.concat(e), t.forEach(function (t, s) {\n      \"undefined\" == typeof n[s] ? n[s] = t : i.isPlainObject(t) ? n[s] = i.merge(e[s], t) : -1 === e.indexOf(t) && n.push(t);\n    }), n) : (e && i.isPlainObject(e) && Object.keys(e).forEach(function (t) {\n      n[t] = e[t];\n    }), Object.keys(t).forEach(function (s) {\n      t[s] && i.isPlainObject(t[s]) && e[s] ? n[s] = i.merge(e[s], t[s]) : n[s] = t[s];\n    }), n);\n  },\n  now: function now() {\n    return window.nwf ? window.nwf.system.Performance.elapsedTime : window.performance.now();\n  },\n  empty: function empty(e) {\n    for (; e.lastChild;) {\n      e.removeChild(e.lastChild);\n    }\n  },\n  radixSort: function radixSort(e, t, i, s) {\n    if (t = t || 0, i = i || e.length, s = s || 31, !(t >= i - 1 || 0 > s)) {\n      for (var n = t, l = i, r = 1 << s; l > n;) {\n        if (e[n] & r) {\n          --l;\n          var h = e[n];\n          e[n] = e[l], e[l] = h;\n        } else ++n;\n      }\n\n      this.radixSort(e, t, l, s - 1), this.radixSort(e, l, i, s - 1);\n    }\n  },\n  randomizeRGB: function randomizeRGB(e, t) {\n    var i,\n        s,\n        n = e.split(\",\"),\n        l = \"rgb(\";\n\n    for (t = this.randomInt(t), i = 0; 3 > i; i++) {\n      s = parseInt(n[i]) + t, 0 > s ? s = 0 : s > 255 && (s = 255), l += s + \",\";\n    }\n\n    return l = l.substring(0, l.length - 1), l += \")\";\n  },\n  getJSON: function getJSON(e) {\n    var t = new XMLHttpRequest(),\n        i = \"undefined\" == typeof e.cache ? !1 : e.cache,\n        s = i ? e.url : e.url + \"?t=\" + Math.floor(1e4 * Math.random()) + Date.now();\n    t.onreadystatechange = function () {\n      if (200 === this.status) {\n        var t = null;\n\n        try {\n          t = JSON.parse(this.responseText);\n        } catch (i) {\n          return;\n        }\n\n        return void e.callback.call(e.scope || null, t);\n      }\n\n      0 !== this.status && console.warn(\"[Tools.getJSON] Error: \" + this.status + \" (\" + this.statusText + \") :: \" + e.url);\n    }, t.open(\"GET\", s, !0), t.setRequestHeader(\"Accept\", \"application/json\"), t.setRequestHeader(\"Content-Type\", \"application/json\"), t.send(\"\");\n  }\n};","map":null,"metadata":{},"sourceType":"script"}