{"ast":null,"code":"var createPatternBuilder = require('./createPatternBuilder');\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  var code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  var pattern = createPatternBuilder(dimension);\n  var code = \"\\n  var length = bodies.length;\\n  if (length === 0) return 0;\\n\\n  \".concat(pattern('var d{var} = 0, t{var} = 0;', {\n    indent: 2\n  }), \"\\n\\n  for (var i = 0; i < length; ++i) {\\n    var body = bodies[i];\\n    if (body.isPinned) continue;\\n\\n    if (adaptiveTimeStepWeight && body.springCount) {\\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\\n    }\\n\\n    var coeff = timeStep / body.mass;\\n\\n    \").concat(pattern('body.velocity.{var} += coeff * body.force.{var};', {\n    indent: 4\n  }), \"\\n    \").concat(pattern('var v{var} = body.velocity.{var};', {\n    indent: 4\n  }), \"\\n    var v = Math.sqrt(\").concat(pattern('v{var} * v{var}', {\n    join: ' + '\n  }), \");\\n\\n    if (v > 1) {\\n      // We normalize it so that we move within timeStep range. \\n      // for the case when v <= 1 - we let velocity to fade out.\\n      \").concat(pattern('body.velocity.{var} = v{var} / v;', {\n    indent: 6\n  }), \"\\n    }\\n\\n    \").concat(pattern('d{var} = timeStep * body.velocity.{var};', {\n    indent: 4\n  }), \"\\n\\n    \").concat(pattern('body.pos.{var} += d{var};', {\n    indent: 4\n  }), \"\\n\\n    \").concat(pattern('t{var} += Math.abs(d{var});', {\n    indent: 4\n  }), \"\\n  }\\n\\n  return (\").concat(pattern('t{var} * t{var}', {\n    join: ' + '\n  }), \")/length;\\n\");\n  return code;\n}","map":null,"metadata":{},"sourceType":"script"}